<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just do IT</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://niuzhiqiang90.coding.me/"/>
  <updated>2018-10-17T12:45:36.200Z</updated>
  <id>http://niuzhiqiang90.coding.me/</id>
  
  <author>
    <name>Niu Zhiqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis主从</title>
    <link href="http://niuzhiqiang90.coding.me/2018/10/17/Redis%E4%B8%BB%E4%BB%8E/"/>
    <id>http://niuzhiqiang90.coding.me/2018/10/17/Redis主从/</id>
    <published>2018-10-17T07:58:19.000Z</published>
    <updated>2018-10-17T12:45:36.200Z</updated>
    
    <content type="html"><![CDATA[<p>Redis支持简单且易用的主从复制功能</p><h2 id="1-Redis复制功能的几个重要方面"><a href="#1-Redis复制功能的几个重要方面" class="headerlink" title="1. Redis复制功能的几个重要方面"></a>1. Redis复制功能的几个重要方面</h2><ul><li>Redis使用异步复制。从服务器会以每秒一次的频率向主服务器报告复制流的处理进度。</li><li>一个主服务器可以有多个从服务器。</li><li>从服务器也可以有多个从服务器，多个从服务器之间可以构成一个图状结构。</li><li>复制功能不会阻塞主服务器。即使一个或多个从服务器正在进行初次同步，主服务器也可以继续处理命令请求。</li><li>复制功能也不会阻塞从服务器，只要在配置文件中进行了相应的配置，即使从服务器正在进行初次同步，服务器也可以使用旧版本的数据集来处理命令查询。<br>不过，在服务器删除旧版本数据集并载入新版本数据集的时间间隔内，连接请求会被阻塞。<br>还可以配置从服务器，让它在与主服务器的连接断开时，向客户端发送一个错误。</li><li>复制功能可以单纯地用于数据冗余，也可以通过让多个从服务器处理只读命令来提升扩展性：比如繁重的<code>SORT</code>命令可以交给附属节点去运行。</li><li>可以通过复制功能来让主服务器免于执行持久化操作：只要关闭主服务器的持久化功能，然后由从服务器去执行持久化操作即可。</li></ul><h2 id="2-复制功能的原理"><a href="#2-复制功能的原理" class="headerlink" title="2.复制功能的原理"></a>2.复制功能的原理</h2><ol><li>无论是初次连接还是重新连接，当建立一个从服务器时，从服务器都将向主服务器发送一个<code>SYNC</code>命令。</li><li>接到<code>SYNC</code>命令的主服务器将开始执行<code>BGSAVE</code>，并在保存操作执行期间，将所有新执行的写入命令都保存到一个缓冲区里。</li><li>当<code>BGSAVE</code>执行完毕后，主服务器将执行保存操作所得的<code>.rdb</code>文件发送给从服务器，从服务器接收到<code>.rdb</code>文件后，将文件中的数据载入到内存中。</li><li>之后，主服务器会以Redis命令协议的格式，将写命令缓冲区中积累的所有内容都发送给从服务器。</li></ol><p>即使有多个从服务器同时向主服务器发送<code>SYNC</code>，主服务器也只需要执行一次<code>BGSAVE</code>命令就可以处理所有这些从服务器的同步请求。</p><p>从服务器可以在主从服务器之间的连接断开时进行自动重连<br>在Redis 2.8之前，断线重连的从服务器总要执行一次完整重同步操作。<br>在Redis 2.8之后，从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步。</p><h2 id="3-部分重同步"><a href="#3-部分重同步" class="headerlink" title="3. 部分重同步"></a>3. 部分重同步</h2><p>从Redis 2.8开始，在网络连接短暂断开后，主从服务器可以尝试继续执行原有的复制进程，而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区，并且主服务器和所有从服务器之间都记录一个复制偏移量和一个主服务器ID，当出现网络断开时，从服务器将重新连接，并且向主服务器请求继续执行原来的复制进程。</p><ul><li>如果从服务器记录的主服务器ID和当前要连接的主服务器的ID相同，并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里，那么主服务器会向从服务器发送断线时缺失的那部分数据，然后复制工作可以继续进行。</li><li>否则。从服务器要执行完整重同步操作。</li></ul><p>Redis的部分重同步特性会用到一个新增的<code>PSYNC</code>内部命令，而Redis 2.8之前的旧版本只有<code>SYNC</code>命令，不过只要从服务器是Redis 2.8或者以上的版本，它会根据主服务器的版本来决定到底是使用<code>PSYNC</code>还是<code>SYNC</code></p><ul><li>主服务器 &gt;= 2.8 从服务器使用<code>PSYNC</code>命令来进行同步。 </li><li>主服务器 &lt; 2.8 从服务器使用<code>SYNC</code>命令来进行同步。 </li></ul><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><p>配置一个从服务器非常简单，只要在配置文件中增加以下一行就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.100 6379</span><br></pre></td></tr></table></figure></p><p>当然，你需要将代码中的<code>192.168.1.100</code> 和<code>6379</code>替换成你的主服务器的IP和端口号。<br>另外一种方法是调用<code>SLAVEOF</code>命令，输入主服务器的IP和端口号，然后同步就会开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 192.168.1.100 6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>在从服务器上登录Redis客户端查询，可以看到数据已经从主服务器同步过来。</p><h2 id="5-只读从服务器"><a href="#5-只读从服务器" class="headerlink" title="5. 只读从服务器"></a>5. 只读从服务器</h2><p>从Redis 2.6开始，从服务器支持只读模式，并且该模式为从服务器的默认模式。</p><p>只读模式由配置文件中的 <code>slave-read-only</code>选项控制，也可以通过<code>CONFIG SET</code>命令来开启或者关闭这个模式。</p><p>只读从服务器会拒绝执行任何写命令，所以不会出现因为操作失误而将数据不小心写到了从服务器的情况。</p><p>即使从服务器是只读的，<code>DEBUG</code>和<code>CONFIG</code> 等管理命令仍然是可以使用的，所以我们还是不应该将服务器暴露给互联网或者任何不可信的网络。不过，使用配置中的命令改名选项，我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p><p>既然从服务器上的写数据会被重同步数据覆盖，也可能在服务器重启时丢失，为什么要让一个从服务器变得可写呢？<br>原因是，一些不重要的临时数据，仍然是可以保存在从服务器上的。</p><h2 id="6-从服务器的相关配置"><a href="#6-从服务器的相关配置" class="headerlink" title="6. 从服务器的相关配置"></a>6. 从服务器的相关配置</h2><p>如果主服务器通过<code>requirepass</code>选项设置了密码，那么为了让从服务器的同步操作可以顺利进行，我们也必须为从服务器进行相应的身份验证设置。</p><p>对于一个正在运行的服务器，可以使用客户端输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>要永久地设置这个密码，那么可以将它加入到配置文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><h2 id="7-主服务器只在有至少N个从服务器的情况下，才执行写操作"><a href="#7-主服务器只在有至少N个从服务器的情况下，才执行写操作" class="headerlink" title="7. 主服务器只在有至少N个从服务器的情况下，才执行写操作"></a>7. 主服务器只在有至少N个从服务器的情况下，才执行写操作</h2><p>从Redis 2.8开始，为了保证数据的安全性，可以通过配置，让主服务器只在有至少N个当前已连接从服务器的情况下，才执行写命令。<br>不过，因为Redis使用异步复制，所以主服务器发送的写数据并不一定会被从服务器收到，因此，数据丢失的可能性仍然是存在的。</p><p>以下是这个特性的原理：</p><ul><li>从服务器以每秒一次的频率<code>ping</code>主服务器一次，并报告复制流的处理情况。</li><li>主服务器会记录各个从服务器最后一次向它发送<code>ping</code>的时间。</li><li>用户可以通过配置，指定网络延迟的最大值<code>min-slaves-max-lag</code>，以及执行写操作所需的至少从服务器数量<code>min-slaves-to-write</code>.</li></ul><p>如果至少有<code>min-slaves-to-write</code>个服务器，并且这些服务器的延迟都少于<code>min-slaves-max-lag</code>秒，那么主服务器就会执行客户端请求的写操作。<br>尽管不能保证写操作的持久性，但起码丢失数据的窗口会被严格限制的指定的秒数中。<br>另一方面，如果条件达不到<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>所指定的条件，那么写操作就不会被执行，主服务器会向请求执行写操作的客户端返回一个错误。<br>以下是这个特性的两个选项和它们所需的参数：</p><ul><li><code>min-slaves-to-write &lt;number of slaves&gt;</code></li><li><code>min-slaves-max-lag &lt;number of second&gt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis支持简单且易用的主从复制功能&lt;/p&gt;
&lt;h2 id=&quot;1-Redis复制功能的几个重要方面&quot;&gt;&lt;a href=&quot;#1-Redis复制功能的几个重要方面&quot; class=&quot;headerlink&quot; title=&quot;1. Redis复制功能的几个重要方面&quot;&gt;&lt;/a&gt;1. R
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://niuzhiqiang90.coding.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://niuzhiqiang90.coding.me/2018/10/16/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://niuzhiqiang90.coding.me/2018/10/16/Redis持久化/</id>
    <published>2018-10-16T12:46:09.000Z</published>
    <updated>2018-10-18T12:54:29.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Redis持久化"><a href="#1-Redis持久化" class="headerlink" title="1. Redis持久化"></a>1. Redis持久化</h2><p>Redis提供了多种不同级别的持久化方式：</p><ul><li>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照。</li><li>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。<br>AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件的末尾。<br><strong>Redis还可以在后台对AOF文件进行重写，使得AOF文件的体积不会超出保存数据集状态所需的实际大小。</strong></li><li>Redis还可以同时使用AOF持久化和RDB持久化。在这种情况下，当Redis重启时，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li><li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><h2 id="2-RDB的优点"><a href="#2-RDB的优点" class="headerlink" title="2. RDB的优点"></a>2. RDB的优点</h2><ul><li>RDB是一个非常紧凑的文件，它保存了Redis在某个时间点上的数据集。这种文件非常适合用于进行备份:比如说，你可以每小时备份一次RDB文件，这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB非常适用于灾难恢复：它只有一个文件，并且内容都非常紧凑。</li><li>RDB最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是<code>fork</code>出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O操作。</li><li>RDB在恢复大数据集时的速度比AOF的恢复速度快。</li></ul><h2 id="3-RDB的缺点"><a href="#3-RDB的缺点" class="headerlink" title="3. RDB的缺点"></a>3. RDB的缺点</h2><ul><li>RDB不适用于尽量避免在服务器故障时丢失数据。虽然Redis允许你设置不同的保存点来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少5分钟才保存一次RDB文件。在这种情况下，一旦发生故障停机，你就可能丢失好几分钟的数据。</li><li>每次保存RDB文件的时候，Redis都要<code>fork()</code>出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时，<code>fork()</code>可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。虽然AOF重写也需要进行<code>fork()</code>,但无论AOF重写的执行间隔有多长，数据的耐久性都不会又任何损失。</li></ul><h2 id="4-AOF的优点"><a href="#4-AOF的优点" class="headerlink" title="4. AOF的优点"></a>4. AOF的优点</h2><ul><li>使用AOF持久化会让Redis变得非常耐久<br>你可以设置不同的<code>fsync</code>策略，比如：无<code>fsync</code>、每秒一次<code>fsync</code>或者每次执行写入命令时<code>fsync</code><br><strong>AOF默认策略为每秒钟<code>fsync</code>一次</strong>，在这种配置下，Redis仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据。（<code>fsync</code>会在后台线程执行，所以主线程可以继续努力地处理命令请求）</li><li>AOF文件是一个只进行追加操作的日志文件，因此对AOF文件的写入不需要进行<code>seek</code>，即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机等），<code>redis-check-aof</code>工具也可以轻易的修复这种问题。</li><li>Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写。重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新AOF文件的过程中，会继续将命令追加到现有AOF文件里面，即使重写过程中发生停机，现有的AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。</li><li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此，AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松。导出AOF文件也非常简单：举个例子，如果你不小心执行了<code>FLUSHALL</code>命令，只要AOF文件没有被重写，那么只要停止服务器，移除AOF文件末尾的<code>FLUSHALL</code>命令，并重启Redis，就可以将数据集恢复到<code>FLUSHALL</code>执行之前的状态。</li></ul><h2 id="5-AOF的缺点"><a href="#5-AOF的缺点" class="headerlink" title="5. AOF的缺点"></a>5. AOF的缺点</h2><ul><li>对于相同的数据集来说，AOF文件的要大于RDB文件。</li><li>根据所使用的<code>fsync</code>策略，AOF的速度可能会慢于RDB。在一般情况下，每秒<code>fsync</code>的性能依然非常高，而关闭<code>fsync</code>可以让AOF的速度和RDB一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间。</li><li>AOF在过去曾经发生过<strong>因为个别命令的原因，导致AOF文件在重新载入时，无法将数据集恢复成保存时的原样</strong>的bug.(例如：阻塞命令<code>BRPOPLPUSH</code>就曾经引起过这样的bug)测试套件里为这种情况添加了测试：它们会自动生成随机的、复杂的数据集，并通过重新载入这些数据来确保一切正常。虽然这种bug在AOF文件中并不常见，单对比来说，RDB几乎是不可能出现这种bug的。</li></ul><h2 id="6-RDB和AOF的选择"><a href="#6-RDB和AOF的选择" class="headerlink" title="6. RDB和AOF的选择"></a>6. RDB和AOF的选择</h2><ul><li>一般来说。如果想要达到足以媲美PostgreSQL的数据安全性，应该同时使用这两种持久化功能。</li><li>如果非常关心数据，但是仍然可以承受数分钟以内的数据丢失，那么可以只使用RDB持久化。</li><li>不推荐只使用AOF持久化，因为定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免之前提到的AOF相关的bug。<br>将来可能将AOF和RDB整合成单个持久化模型。</li></ul><h2 id="7-RDB快照"><a href="#7-RDB快照" class="headerlink" title="7. RDB快照"></a>7. RDB快照</h2><p>默认情况下，Redis将数据库快照保存在名字为<code>dump.rdb</code>的二进制文件中。<br>可以对Redis进行设置，让它满足在<strong>N 秒内数据集至少有M个改动</strong>时自动保存一次数据集。<br>也可以通过调用<code>SAVE</code>或<code>BGSAVE</code>手动让Redis进行数据集保存操作。<br>比如，以下设置会让Redis在满足60秒内有至少1000个键被改动时自动保存一次数据集<br><code>save 60 1000</code><br>这种持久化方式被称为快照。</p><h2 id="8-快照的运作方式"><a href="#8-快照的运作方式" class="headerlink" title="8. 快照的运作方式"></a>8. 快照的运作方式</h2><p>当Redis需要保存<code>dump.rdb</code>文件时，服务器执行以下操作</p><ol><li>Redis调用<code>fork()</code>,同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时RDB文件中。</li><li>当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。<br>这种工作方式使得Redis可以从写时复制机制中获益。</li></ol><h2 id="9-只进行追加操作的文件aof"><a href="#9-只进行追加操作的文件aof" class="headerlink" title="9. 只进行追加操作的文件aof"></a>9. 只进行追加操作的文件aof</h2><p>快照功能并不是非常耐久：如果Redis因为某些原因而造成故障停机，那么服务器将丢失最近写入且仍未保存到快照中的哪些数据。<br>尽管对于某些程序来说，数据耐久性并不是最重要的考虑因素，但是对于那些追求完全耐久能力的程序来说，快照功能就不太适用了。<br>打开AOF功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p><p>从现在开始，每当Redis执行一个改变数据集的命令时，这个命令就会被追加到AOF文件的末尾。<br>这样的话，当Redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。 </p><h2 id="10-AOF重写"><a href="#10-AOF重写" class="headerlink" title="10. AOF重写"></a>10. AOF重写</h2><p>因为AOF的运作方式是不断地将命令追加到文件的末尾，所以随着写入命令的不断增加，AOF文件的体积也会变得越来越大。<br>例如：如果你对一个计数器调用了100次<code>INCR</code>，那么仅仅是为了保存这个计数器的当前值，AOF文件就需要使用100条记录。<br>然而实际上，只需要一条<code>SET</code>命令已经足以保存计数器的当前值了，其余99条记录实际上都是多余的。<br>为了处理这种情况，Redis支持一种有趣的特性：可以在不打断服务客户端的情况下，对AOF文件进行重建。<br>执行<code>BGREWRITEAOF</code>命令，Redis将生成一个新的AOF文件，这个文件包含重建当前数据集所需的最少命令。</p><h2 id="11-AOF有多耐久"><a href="#11-AOF有多耐久" class="headerlink" title="11. AOF有多耐久"></a>11. AOF有多耐久</h2><p>可以配置Redis多久才将数据<code>fsync</code>磁盘一次。<br>有三个选项：</p><ul><li>每次有新命令追加到AOF文件时就执行一次<code>fsync</code>:非常慢，也非常安全。</li><li>每秒<code>fsync</code>一次：足够快（和使用RDB持久化差不多），并且在故障时只会丢失1秒的数据。</li><li>从不<code>fsync</code>:将数据交给操作系统来处理。更快，也更不安全的选择。<br>推荐并且默认的措施是每秒<code>fsync</code>一次，这种<code>fsync</code>策略可以兼顾速度和安全性。</li></ul><h2 id="12-如果AOF文件出错了，怎么办？"><a href="#12-如果AOF文件出错了，怎么办？" class="headerlink" title="12. 如果AOF文件出错了，怎么办？"></a>12. 如果AOF文件出错了，怎么办？</h2><p>服务器可能在程序正在对AOF文件进行写入是停机，如果停机造成了AOF文件出错，那么Redis在重启时会拒绝载入这个AOF文件，从而确保数据的一致性不会被破坏。<br>当发生这种情况时，可以使用以下方法来修复出错的AOF文件：</p><ol><li>为现有的AOF文件创建一个备份</li><li><p>使用Redis附带的<code>Redis-check-aof</code>程序对原来的AOF文件进行修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-check-aof --fix</span><br></pre></td></tr></table></figure></li><li><p>[可选] 使用<code>diff -u</code>对比修复后的AOF文件和原始AOF文件的备份。查看两个文件之间的不同之处。</p></li><li>重启Redis服务器，等待服务器载入修复后的AOF文件，并进行数据恢复。</li></ol><h2 id="13-AOF的运作方式"><a href="#13-AOF的运作方式" class="headerlink" title="13. AOF的运作方式"></a>13. AOF的运作方式</h2><p>AOF重写和RDB创建快照一样，都巧妙地利用了写时复制。<br>以下是AOF重写的执行步骤：</p><ol><li>Redis执行<code>fork()</code>，现在同时拥有父进程和子进程。</li><li>子进程开始将新AOF文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们积累到一个内存缓存中，一边将这些改动追加到现有AOF文件的末尾：这样即使在重写的中途发生停机，现有的AOF文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号后，将内存缓存中的所有数据追加到新AOF文件的末尾。</li><li>现在Redis原子地用新文件替换旧文件，之后所有命令都会直接追加到新AOF文件的末尾。</li></ol><h2 id="14-怎么从RDB持久化切换到AOF持久化"><a href="#14-怎么从RDB持久化切换到AOF持久化" class="headerlink" title="14. 怎么从RDB持久化切换到AOF持久化"></a>14. 怎么从RDB持久化切换到AOF持久化</h2><p>在Redis2.2或以上版本，可以在不重启的情况下，从RDB切换到AOF：  </p><ol><li>为最新的<code>dump.rdb</code>文件创建一个备份。</li><li>将备份放到一个安全的地方。</li><li><p>执行以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启AOF功能：Redis会阻塞直到初始AOF文件创建完成为止，之后Redis会继续处理命令请求，并开始将写入命令追加到AOF文件末尾  </span><br><span class="line">redis-cli&gt; CONFIG SET appendonly yes  </span><br><span class="line">关闭RDB功能 这一步是可选的，如果愿意的话也可以同时使用RDB和AOF这两种持久化功能</span><br><span class="line">redis-cli&gt; CONFIG SET save &quot; &quot;</span><br></pre></td></tr></table></figure></li><li><p>确保命令执行之后，数据库的键的数量没有改变。  </p></li><li>确保写命令会被正确地追加到AOF文件的末尾。<br><strong>别忘了在配置文件中打开AOF功能！否则，服务器重启之后，之前通过<code>CONFIG SET</code>设置的配置就会被遗忘，程序会按原来的配置启动服务器</strong><br><strong><font color="red">不可以直接修改配置文件重启服务，这样会从空的aof文件里读取，导致数据集被清空</font></strong></li></ol><h2 id="15-RDB和AOF之间的相互作用"><a href="#15-RDB和AOF之间的相互作用" class="headerlink" title="15. RDB和AOF之间的相互作用"></a>15. RDB和AOF之间的相互作用</h2><p>在版本号大于等于2.4的Redis中，<code>BGSAVE</code>执行的过程中，不可以执行<code>BGREWRITEAOF</code><br>反过来，在<code>BGREWRITEAOF</code>执行的过程中，也不可以执行<code>BGSAVE</code><br>这可以防止两个Redis后台进程同时对磁盘进行大量的I/O操作。<br>如果<code>BGSAVE</code>正在执行，并且用户显式地调用<code>BGREWRITEAOF</code>命令，那么服务器将向用户回复一个OK状态，并告知用户。<br><code>BGREWRITEAOF</code>已经被预订执行：一旦<code>BGSAVE</code>执行完毕，<code>BGREWRITEAOF</code>就会正式开始。<br>当Redis启动时，如果RDB持久化和AOF持久化都被打开了，那么程序会优先使用AOF文件来恢复数据集，因为AOF文件所保存的数据通常是最完整的。</p><h2 id="16-备份Redis数据"><a href="#16-备份Redis数据" class="headerlink" title="16. 备份Redis数据"></a>16. 备份Redis数据</h2><p>一定要备份你的数据库！<br>磁盘故障，节点失效，诸如此类的问题都可能让你的数据消失不见，不进行备份是非常危险的<br>Redis对于数据备份是非常友好的，因为你可以在服务器运行时对RDB文件进行复制：RDB文件一旦被创建，就不会进行任何修改。当服务器要创建一个新的RDB文件时，它先将文件的内容保存在一个临时文件里面，当临时文件写入完毕时，程序才使用rename原子地用临时文件替换原来的RDB文件。<br>也就是说，无论何时，复制RDB文件都是绝对安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Redis持久化&quot;&gt;&lt;a href=&quot;#1-Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;1. Redis持久化&quot;&gt;&lt;/a&gt;1. Redis持久化&lt;/h2&gt;&lt;p&gt;Redis提供了多种不同级别的持久化方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python字符串对齐</title>
    <link href="http://niuzhiqiang90.coding.me/2018/10/13/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E9%BD%90/"/>
    <id>http://niuzhiqiang90.coding.me/2018/10/13/python字符串对齐/</id>
    <published>2018-10-13T03:15:18.000Z</published>
    <updated>2018-10-17T12:45:21.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python字符串对齐"><a href="#python字符串对齐" class="headerlink" title="python字符串对齐"></a>python字符串对齐</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title = &quot;九九乘法口诀表&quot;</span><br></pre></td></tr></table></figure><h2 id="1-使用ljust-rjust-center方法"><a href="#1-使用ljust-rjust-center方法" class="headerlink" title="1. 使用ljust,rjust,center方法"></a>1. 使用<code>ljust</code>,<code>rjust</code>,<code>center</code>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ljust(s, width, *args)</span><br><span class="line">        ljust(s, width[, fillchar]) -&gt; string</span><br><span class="line">        </span><br><span class="line">        Return a left-justified version of s, in a field of the</span><br><span class="line">        specified width, padded with spaces as needed.  The string is</span><br><span class="line">        never truncated.  If specified the fillchar is used instead of spaces.</span><br><span class="line"></span><br><span class="line">rjust(s, width, *args)</span><br><span class="line">        rjust(s, width[, fillchar]) -&gt; string</span><br><span class="line">        </span><br><span class="line">        Return a right-justified version of s, in a field of the</span><br><span class="line">        specified width, padded with spaces as needed.  The string is</span><br><span class="line">        never truncated.  If specified the fillchar is used instead of spaces.</span><br><span class="line"></span><br><span class="line">center(s, width, *args)</span><br><span class="line">        center(s, width[, fillchar]) -&gt; string</span><br><span class="line">        </span><br><span class="line">        Return a center version of s, in a field of the specified</span><br><span class="line">        width. padded with spaces as needed.  The string is never</span><br><span class="line">        truncated.  If specified the fillchar is used instead of spaces.</span><br></pre></td></tr></table></figure><p>不指定填充字符默认空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 左对齐</span><br><span class="line">print(title.ljust(100))</span><br><span class="line"># 右对齐</span><br><span class="line">print(title.rjust(100))</span><br><span class="line"># 居中 </span><br><span class="line">print(title.center(100))</span><br></pre></td></tr></table></figure></p><p>指定填充字符为星号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(title.ljust(100,&apos;*&apos;))</span><br><span class="line">print(title.rjust(100,&apos;*&apos;))</span><br><span class="line">print(title.center(100,&apos;*&apos;))</span><br></pre></td></tr></table></figure></p><h2 id="2-使用format方法"><a href="#2-使用format方法" class="headerlink" title="2. 使用format方法"></a>2. 使用<code>format</code>方法</h2><p><code>&lt;</code> 左对齐<br><code>&gt;</code> 右对齐<br><code>^</code> 居中对齐<br>不指定填充字符默认空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(format(title,&quot;&lt;100&quot;));</span><br><span class="line">print(format(title,&quot;&gt;100&quot;));</span><br><span class="line">print(format(title,&quot;^100&quot;));</span><br><span class="line"></span><br><span class="line">print(&apos;&#123;:&lt;100&#125;&apos;.format(title))</span><br><span class="line">print(&apos;&#123;:&gt;100&#125;&apos;.format(title))</span><br><span class="line">print(&apos;&#123;:^100&#125;&apos;.format(title))</span><br></pre></td></tr></table></figure></p><p>指定填充字符为星号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(format(title,&quot;*&lt;100&quot;));</span><br><span class="line">print(format(title,&quot;*&gt;100&quot;));</span><br><span class="line">print(format(title,&quot;*^100&quot;));</span><br><span class="line"></span><br><span class="line">print(&apos;&#123;:*&lt;100&#125;&apos;.format(title))</span><br><span class="line">print(&apos;&#123;:&gt;*100&#125;&apos;.format(title))</span><br><span class="line">print(&apos;&#123;:^*100&#125;&apos;.format(title))</span><br></pre></td></tr></table></figure></p><p>精度与类型f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&#123;:.2f&#125;&apos;.format(3.1415926))</span><br></pre></td></tr></table></figure></p><p>进制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&#123;:b&#125;&apos;.format(13))</span><br><span class="line">print(&apos;&#123;:o&#125;&apos;.format(13))</span><br><span class="line">print(&apos;&#123;:d&#125;&apos;.format(13))</span><br><span class="line">print(&apos;&#123;:x&#125;&apos;.format(13))</span><br></pre></td></tr></table></figure></p><p>用逗号作金额的分隔符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&#123;:,&#125;&apos;.format(123456789))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python字符串对齐&quot;&gt;&lt;a href=&quot;#python字符串对齐&quot; class=&quot;headerlink&quot; title=&quot;python字符串对齐&quot;&gt;&lt;/a&gt;python字符串对齐&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="python" scheme="http://niuzhiqiang90.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>git bisect</title>
    <link href="http://niuzhiqiang90.coding.me/2017/08/30/git-bisect/"/>
    <id>http://niuzhiqiang90.coding.me/2017/08/30/git-bisect/</id>
    <published>2017-08-30T14:06:12.000Z</published>
    <updated>2017-08-30T14:10:53.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git bisect"></a>git bisect</h1><p>在提交了多次代码后，发现代码不能正确运行了，但是很确定的是某一个commit是好使的，比如昨天晚上或者上午的某次提交是可以正确运行的，这个时候可以通过<code>git bisect</code>来通过二分查找出问题的那次提交</p><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br></pre></td></tr></table></figure><h2 id="2-标记当前的HEAD为bad"><a href="#2-标记当前的HEAD为bad" class="headerlink" title="2.标记当前的HEAD为bad"></a>2.标记当前的HEAD为bad</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect bad</span><br></pre></td></tr></table></figure><h2 id="3-标记最近一次可以正确运行的commit为good"><a href="#3-标记最近一次可以正确运行的commit为good" class="headerlink" title="3.标记最近一次可以正确运行的commit为good"></a>3.标记最近一次可以正确运行的commit为good</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect good &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="4-检查中间的那次提交状态是正确还是错误"><a href="#4-检查中间的那次提交状态是正确还是错误" class="headerlink" title="4.检查中间的那次提交状态是正确还是错误"></a>4.检查中间的那次提交状态是正确还是错误</h2><ul><li>如果是正确，标记为good<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect good</span><br></pre></td></tr></table></figure></li></ul><p>这时候，git会从这个good到最初标记的bad进行二分查找</p><ul><li>如果是出错的，标记为bad<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect bad</span><br></pre></td></tr></table></figure></li></ul><p>这时候，git会从这个bad到最初标记的good位置进行二分查找</p><h2 id="5-重复步骤4"><a href="#5-重复步骤4" class="headerlink" title="5.重复步骤4"></a>5.重复步骤4</h2><p>即可找到最初的bad是在哪次commit不小心引入的。</p><h2 id="6-结束"><a href="#6-结束" class="headerlink" title="6.结束"></a>6.结束</h2><p>查找到引入bug的commit之后，回到最初的HEAD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect reset</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-bisect&quot;&gt;&lt;a href=&quot;#git-bisect&quot; class=&quot;headerlink&quot; title=&quot;git bisect&quot;&gt;&lt;/a&gt;git bisect&lt;/h1&gt;&lt;p&gt;在提交了多次代码后，发现代码不能正确运行了，但是很确定的是某一个commit
      
    
    </summary>
    
    
      <category term="git" scheme="http://niuzhiqiang90.coding.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>website enable ssl</title>
    <link href="http://niuzhiqiang90.coding.me/2017/08/09/website-enable-ssl/"/>
    <id>http://niuzhiqiang90.coding.me/2017/08/09/website-enable-ssl/</id>
    <published>2017-08-09T12:33:10.000Z</published>
    <updated>2017-08-30T13:49:17.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="website-enable-ssl"><a href="#website-enable-ssl" class="headerlink" title="website enable ssl"></a>website enable ssl</h1><h2 id="1-nginx-enable-ssl"><a href="#1-nginx-enable-ssl" class="headerlink" title="1. nginx enable ssl"></a>1. nginx enable ssl</h2><p>网站启用ssl需要nginx ssl 模块的支持</p><h3 id="1-1-查看nginx是否编译了ssl模块"><a href="#1-1-查看nginx是否编译了ssl模块" class="headerlink" title="1.1 查看nginx是否编译了ssl模块"></a>1.1 查看nginx是否编译了ssl模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure><h3 id="1-2-编译ssl模块"><a href="#1-2-编译ssl模块" class="headerlink" title="1.2 编译ssl模块"></a>1.2 编译ssl模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx/src/dir</span><br><span class="line">./configure --with-http_ssl_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="2-启用ssl"><a href="#2-启用ssl" class="headerlink" title="2. 启用ssl"></a>2. 启用ssl</h2><h3 id="2-1-生成证书"><a href="#2-1-生成证书" class="headerlink" title="2.1 生成证书"></a>2.1 生成证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo openssl genrsa -des3 -out server.key 2048</span><br><span class="line">sudo openssl req -new -key server.key -out server.csr</span><br><span class="line">sudo cp server.key server.key.org</span><br><span class="line">sudo openssl rsa -in server.key.org -out server.key</span><br><span class="line">sudo openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure><h2 id="2-2-在server区域，指定证书位置"><a href="#2-2-在server区域，指定证书位置" class="headerlink" title="2.2 在server区域，指定证书位置"></a>2.2 在server区域，指定证书位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate /dir/server.crt;</span><br><span class="line">ssl_certificate_key /dir/server.key;</span><br></pre></td></tr></table></figure><h2 id="2-3-修改监听的端口号"><a href="#2-3-修改监听的端口号" class="headerlink" title="2.3 修改监听的端口号"></a>2.3 修改监听的端口号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen       443 ssl; </span><br><span class="line">server_name  ssl.test.cn;</span><br></pre></td></tr></table></figure><h2 id="2-4-将http的访问redirect到https"><a href="#2-4-将http的访问redirect到https" class="headerlink" title="2.4 将http的访问redirect到https"></a>2.4 将http的访问redirect到https</h2><p>在http区域添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  ssl.test.cn;;</span><br><span class="line">       return 301 https://ssl.test.cn:443$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-5-重启或者reloadnginx"><a href="#2-5-重启或者reloadnginx" class="headerlink" title="2.5 重启或者reloadnginx"></a>2.5 重启或者reloadnginx</h2><h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6 测试"></a>2.6 测试</h2><p>访问<a href="http://ssl.test.cn" target="_blank" rel="noopener">http://ssl.test.cn</a><br>已经会自动跳转到<a href="https://ssl.test.cn" target="_blank" rel="noopener">https://ssl.test.cn</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;website-enable-ssl&quot;&gt;&lt;a href=&quot;#website-enable-ssl&quot; class=&quot;headerlink&quot; title=&quot;website enable ssl&quot;&gt;&lt;/a&gt;website enable ssl&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://niuzhiqiang90.coding.me/tags/nginx/"/>
    
      <category term="ssl" scheme="http://niuzhiqiang90.coding.me/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>linux系统监控基本命令</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/25/linux%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/25/linux系统监控基本命令/</id>
    <published>2017-03-25T09:09:57.000Z</published>
    <updated>2017-03-27T13:25:05.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-nmon软件"><a href="#1-nmon软件" class="headerlink" title="1. nmon软件"></a>1. nmon软件</h2><h3 id="1-1-运行nmon软件"><a href="#1-1-运行nmon软件" class="headerlink" title="1.1 运行nmon软件"></a>1.1 运行nmon软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:~$ nmon</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌nmon─14g──────[H for help]───Hostname=localhost────Refresh= 2secs ───16:48.29────────────────────────┐</span><br><span class="line">------------------------------       For help type H or ...                                           │</span><br><span class="line">│  #    #  #    #   ####   #    #        nmon -?  - hint                                              │</span><br><span class="line">│  ##   #  ##  ##  #    #  ##   #        nmon -h  - full                                              │</span><br><span class="line">│  # #  #  # ## #  #    #  # #  #                                                                     │</span><br><span class="line">│  #  # #  #    #  #    #  #  # #       To start the same way every time                              │</span><br><span class="line">│  #   ##  #    #  #    #  #   ##        set the NMON ksh variable                                    │</span><br><span class="line">│  #    #  #    #   ####   #    #                                                                     │</span><br><span class="line">│  ------------------------------                                                                     │</span><br><span class="line">│                                                                                                     │</span><br><span class="line">│  Use these keys to toggle statistics on/off:                                                        │</span><br><span class="line">│     c = CPU        l = CPU Long-term   - = Faster screen updates                                    │</span><br><span class="line">│     m = Memory     j = Filesystems     + = Slower screen updates                                    │</span><br><span class="line">│     d = Disks      n = Network         V = Virtual Memory                                           │</span><br><span class="line">│     r = Resource   N = NFS             v = Verbose hints                                            │</span><br><span class="line">│     k = kernel     t = Top-processes   . = only busy disks/procs                                    │</span><br><span class="line">│     h = more options                 q = Quit                                                       │</span><br><span class="line">│─────────────────────────────────────────────────────────────────────────────────────────────────────│</span><br></pre></td></tr></table></figure><h3 id="1-2-显示CPU信息"><a href="#1-2-显示CPU信息" class="headerlink" title="1.2 显示CPU信息"></a>1.2 显示CPU信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">│ CPU Utilisation ──────────────────────────────────────────────────────────────</span><br><span class="line">│---------------------------+-------------------------------------------------+</span><br><span class="line">│CPU  User%  Sys% Wait% Idle|0          |25         |50          |75       100|</span><br><span class="line">│  1  15.2   1.5   0.0  83.2|UUUUUUU           &gt;                              |</span><br><span class="line">│  2   7.1   2.6   0.0  90.3|UUUs             &gt;                               |</span><br><span class="line">│  3  17.5   1.0   0.5  81.0|UUUUUUUU        &gt;                                |</span><br><span class="line">│  4  13.6   3.0   0.0  83.3|UUUUUUs            &gt;                             |</span><br><span class="line">│---------------------------+-------------------------------------------------+</span><br><span class="line">│Avg  13.4   2.1   0.3  84.3|UUUUUUs        &gt;                                 |</span><br><span class="line">│---------------------------+-------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="1-3-显示内存信息"><a href="#1-3-显示内存信息" class="headerlink" title="1.3 显示内存信息"></a>1.3 显示内存信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">│ Memory Stats ──────────────────────────────────────────────────────────────────</span><br><span class="line">                RAM     High      Low     Swap    Page Size=4 KB</span><br><span class="line">│ Total MB      7843.5     -0.0     -0.0   3916.0</span><br><span class="line">│ Free  MB      1259.8     -0.0     -0.0   3915.6</span><br><span class="line">│ Free Percent    16.1%   100.0%   100.0%   100.0%</span><br><span class="line">│             MB                  MB                  MB</span><br><span class="line">│                      Cached=  2912.7     Active=  3842.7</span><br><span class="line">│ Buffers=   929.4 Swapcached=     0.0  Inactive =  1789.8</span><br><span class="line">│ Dirty  =     0.1 Writeback =     0.0  Mapped   =   946.5</span><br><span class="line">│ Slab   =   799.7 Commit_AS =  6624.9 PageTables=    40.2</span><br></pre></td></tr></table></figure><h3 id="1-4-显示磁盘信息"><a href="#1-4-显示磁盘信息" class="headerlink" title="1.4 显示磁盘信息"></a>1.4 显示磁盘信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Disk I/O ──/proc/diskstats────mostly in KB/s─────Warning:contains duplicates────</span><br><span class="line">│DiskName Busy  Read WriteKB|0          |25         |50          |75       100|</span><br><span class="line">│sda        5%    0.0   42.0|WW&gt;                                              |</span><br><span class="line">│sda1       0%    0.0    0.0|&gt;                                                |</span><br><span class="line">│sda2       0%    0.0    0.0|&gt;                                                |</span><br><span class="line">│sda5       5%    0.0   42.0|WW&gt;                                              |</span><br><span class="line">│sda6       0%    0.0    0.0|&gt;                                                |</span><br><span class="line">│Totals Read-MB/s=0.0      Writes-MB/s=0.1      Transfers/sec=12.0</span><br></pre></td></tr></table></figure><h3 id="1-5-显示网络信息"><a href="#1-5-显示网络信息" class="headerlink" title="1.5 显示网络信息"></a>1.5 显示网络信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> Network I/O ────────────────────────────────────────────────────────────────────</span><br><span class="line">│I/F Name Recv=KB/s Trans=KB/s packin packout insize outsize Peak-&gt;Recv Trans </span><br><span class="line">│      lo     0.0     0.0       0.0      0.0     0.0    0.0        0.0     0.0 </span><br><span class="line">│   wlan0     0.1     0.0       0.5      0.0   215.0    0.0        0.1     0.0 </span><br><span class="line">│ docker0     0.0     0.0       0.0      0.0     0.0    0.0        0.0     0.0 </span><br><span class="line">│    eth0     0.0     0.0       0.0      0.0     0.0    0.0        0.0     0.0</span><br><span class="line">│ Network Error Counters ─────────────────────────────────────────────────────────</span><br><span class="line">│I/F Name iErrors iDrop iOverrun iFrame oErrors   oDrop oOverrun oCarrier oColls</span><br><span class="line">│      lo       0       0       0       0       0       0       0       0       0</span><br><span class="line">│   wlan0       0       0       0       0       0       0       0       0       0</span><br><span class="line">│ docker0       0       0       0       0       0       0       0       0       0</span><br><span class="line">│    eth0       0       0       0       0       0       0       0       0       0</span><br></pre></td></tr></table></figure><h3 id="1-6-显示内核信息"><a href="#1-6-显示内核信息" class="headerlink" title="1.6 显示内核信息"></a>1.6 显示内核信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kernel Stats ────────────────────────────────────────────────────────────────────</span><br><span class="line">│ RunQueue              3   Load Average    CPU use since boot time</span><br><span class="line">│ ContextSwitch    2735.0    1 mins  0.54    Uptime Days=  0 Hours= 7 Mins=58</span><br><span class="line">│ Forks               0.5    5 mins  0.86    Idle   Days=  1 Hours= 1 Mins=36</span><br><span class="line">│ Interrupts        836.9   15 mins  0.92    Average CPU use=-221.51%</span><br></pre></td></tr></table></figure><h2 id="2-ethstatus"><a href="#2-ethstatus" class="headerlink" title="2. ethstatus"></a>2. ethstatus</h2><p><code>ethstatus</code>可以实时监控网卡的带宽占用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">───────────────────.EthStatus v0.4a.──────────────────────────────[0/910]──────────────────────│</span><br><span class="line">│                                                                                              │</span><br><span class="line">│                                                                                              │</span><br><span class="line">│                      ######                                                                  │</span><br><span class="line">│                                                                                              │</span><br><span class="line">│         ###                                                                                  │</span><br><span class="line">│        ON/OFF                      RX  TX                                                    │</span><br><span class="line">│                            0.00 B/s   0 Packets/s                                            │</span><br><span class="line">│                                                                                              │</span><br><span class="line">│                                                                                              │</span><br><span class="line">│     IP Address:          192.168.1.116                                                       │</span><br><span class="line">│     Interface name:      wlan0         Graphic Using Speed:    9.77 MB/s                     │</span><br><span class="line">│     Top Speed:           732.00 B/s    Top Packets/s:          5                             │</span><br><span class="line">│     Received Packets:    593428        Transmited Packets:     437965                        │</span><br><span class="line">│     Received:            399.68 MB     Transmitted:            54.73 MB                      │</span><br><span class="line">│     Errors on Receiving: 0             Errors on Transmission: 0                             │</span><br><span class="line">│                                                                                              │</span><br><span class="line">│                                                                                              │</span><br></pre></td></tr></table></figure><h2 id="3-iftop监控网卡实时流量"><a href="#3-iftop监控网卡实时流量" class="headerlink" title="3. iftop监控网卡实时流量"></a>3. iftop监控网卡实时流量</h2><p>常用参数列表</p><table><thead><tr><th>参数</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>-i</td><td>指定需要监测的网卡</td><td>sudo iftop -i wlan0</td></tr><tr><td>-n</td><td>将输出的主机信息都通过ip显示，不进行DNS方向解析</td><td>sudo iftop -n -i wlan0</td></tr><tr><td>-B</td><td>将输出以byte为单位显示网卡流量，默认是bit</td><td>sudo iftop -B -i wlan0</td></tr><tr><td>-p</td><td>以混杂模式运行iftop,此时iftop可以作为网络嗅探器</td><td>sudo iftop -p -i wlan0</td></tr><tr><td>-N</td><td>只显示链接端口号，不显示对应的服务名称</td><td>sudo iftop -N -i wlan0</td></tr><tr><td>-P</td><td>显示主机及端口信息</td><td>sudo iftop -P -i wlan0</td></tr><tr><td>-F</td><td>显示特定网段的网卡进出流量</td><td>sudo iftop -F 192.168.1.10/24</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                    12.5kb              25.0kb               37.5kb              50.0kb         [0/37]</span><br><span class="line">+-------------------+-------------------+--------------------+-------------------+--------------------</span><br><span class="line">192.168.1.116                         =&gt; 101.227.160.102                       17.6kb  3.55kb  1.90kb </span><br><span class="line">                                      &lt;=                                       7.29kb  1.50kb   807b</span><br><span class="line">224.0.0.251                           =&gt; 192.168.1.165                            0b      0b      0b  </span><br><span class="line">                                      &lt;=                                       1.72kb  2.21kb   566b</span><br><span class="line">192.168.1.116                         =&gt; 140.206.160.161                       4.89kb  0.98kb  1.21kb</span><br><span class="line">                                      &lt;=                                       1.18kb   242b    302b</span><br><span class="line">192.168.1.116                         =&gt; 192.168.1.1                              0b    112b     96b  </span><br><span class="line">                                      &lt;=                                          0b    378b    254b</span><br><span class="line">239.255.255.250                       =&gt; 192.168.1.148                            0b      0b      0b</span><br><span class="line">                                      &lt;=                                       1.19kb   486b    730b</span><br><span class="line">224.0.0.251                           =&gt; 192.168.1.166                            0b      0b      0b</span><br><span class="line">                                      &lt;=                                        272b     54b     14b</span><br><span class="line">192.168.1.165                         =&gt; all-routers.mcast.net                    0b     26b      6b</span><br><span class="line">                                      &lt;=                                          0b      0b      0b</span><br><span class="line">192.168.1.116                         =&gt; 101.226.76.164                           0b      0b   2.11kb</span><br><span class="line">                                      &lt;=                                          0b      0b    752b  </span><br><span class="line">192.168.1.116                         =&gt; dev                                      0b      0b   1.50kb</span><br><span class="line">                                      &lt;=                                          0b      0b    544b</span><br><span class="line">192.168.1.116                         =&gt; stage                                    0b      0b   1.40kb</span><br><span class="line">                                      &lt;=                                          0b      0b    504b</span><br><span class="line">239.255.255.250                       =&gt; 192.168.1.135                            0b      0b      0b</span><br><span class="line">                                      &lt;=                                          0b      0b    161b</span><br><span class="line">239.255.255.250                       =&gt; 192.168.1.113                            0b      0b      0b</span><br><span class="line">                                      &lt;=                                          0b      0b    160b</span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line">TX:             cum:   51.5kB   peak:   44.7kb                        rates:   22.4kb  4.64kb  8.27kb</span><br><span class="line">RX:                    46.8kB           28.5kb                                 11.6kb  4.87kb  4.94kb</span><br><span class="line">TOTAL:                 98.4kB           73.2kb                                 34.1kb  9.51kb  13.2kb</span><br></pre></td></tr></table></figure><h2 id="4-mtr"><a href="#4-mtr" class="headerlink" title="4. mtr"></a>4. mtr</h2><p>mtr是Linux中有一个非常棒的网络连通性判断工具,它结合了<code>ping</code>，<code>traceroute</code>，<code>nslookup</code>的相关特性。<br>相对于其他命令仅仅收集传输路径或响应时间，MTR 工具会收集更多的信息，比如 连接状态，连接可用性，以及传输路径中主机的响应性。</p><p>常用参数</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-s</td><td>用来指定ping数据包的大小</td></tr><tr><td><code>--no-dns</code></td><td>不对IP地址做域名解析</td></tr><tr><td>-a</td><td>使用这个参数来设置ICMP返回之间的要求默认是1秒</td></tr><tr><td><code>--report</code></td><td>给主机发送10个ICMP包，然后输出报告</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                    My traceroute  [v0.85]                                     [0/102]</span><br><span class="line">localhost (0.0.0.0)                            Sun Mar 26 20:25:43 2017</span><br><span class="line">Keys:  Help   Display mode   Restart statistics   Order of fields   quit</span><br><span class="line">                                            Packets               Pings</span><br><span class="line"> Host                                    Loss%   Snt   Last   Avg  Best  Wrst StDev</span><br><span class="line"> 1. 192.168.0.1                           0.0%     8    1.5   2.3   1.3   4.3   0.8</span><br><span class="line"> 2. 192.168.1.1                           0.0%     8    1.7   4.6   1.7  13.7   5.2</span><br><span class="line"> 3. 114.245.248.1                         0.0%     8   78.3 108.3   3.7 363.8 149.8</span><br><span class="line"> 4. 123.126.26.45                         0.0%     8    7.9  19.6   3.8  76.7  26.3</span><br><span class="line"> 5. 61.148.158.53                         0.0%     8    7.2  12.2   5.1  31.6   9.2</span><br><span class="line"> 6. 61.51.115.106                         0.0%     8   78.8  15.4   4.6  78.8  25.7</span><br><span class="line"> 7. 61.49.168.110                         0.0%     8    4.9   7.1   4.8  12.8   2.7</span><br><span class="line"> 8. ???</span><br><span class="line"> 9. ???</span><br><span class="line">10. 61.135.169.121                        0.0%     7    4.3   5.9   4.2  10.9   2.2</span><br></pre></td></tr></table></figure><p><strong>说明</strong><br>当分析mtr的输出时，需要注意两点:loss和latency<br>如果你在任何一跳上看到loss的百分比，这就说明这一跳上可能有问题。当然也有可能是服务提供商人为限制了ICMP发送的速率，也会导致丢包。如果下一跳没有丢包，那说明该丢包是人为限制的。<br>如果第4跳和第5跳都有50%的丢包率，从接下来的几跳都有丢包现象，所以不像是人为限制 ICMP 速率的原因。但是最后几跳都是30%的丢包率，我们可以猜测30%的丢包率除了网络糟糕的原因之前还有人为限制ICMP。所以，当我们看到不同的丢包率时，通常要以最后几跳为准。当出现短暂的10%丢包率的时候，不必担心，应用层的程序会弥补这点损失。</p><h2 id="5-htop"><a href="#5-htop" class="headerlink" title="5. htop"></a>5. htop</h2><p>常用功能键</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>F1</td><td>帮助</td></tr><tr><td>F2</td><td>设置</td></tr><tr><td>F3</td><td>搜索进程</td></tr><tr><td>F4</td><td>过滤器，按关键字搜索</td></tr><tr><td>F5</td><td>显示树形结构</td></tr><tr><td>F6</td><td>选择排序方式</td></tr><tr><td>F7</td><td>减少nice值，可以提高对应进程的优先级</td></tr><tr><td>F8</td><td>增加nice值，可以降低对应进程的优先级</td></tr><tr><td>F9</td><td>杀掉选中的进程</td></tr><tr><td>F10</td><td>退出</td></tr><tr><td>/</td><td>搜索字符</td></tr><tr><td>h</td><td>显示帮助</td></tr><tr><td>l</td><td>显示进程打开的文件 lsof</td></tr><tr><td>u</td><td>显示所有用户，并可以选择某一特定用户的进程</td></tr><tr><td>s</td><td>将调用strace追踪进程的系统调用</td></tr><tr><td>t</td><td>显示树形结构</td></tr><tr><td>H</td><td>显示/隐藏用户线程</td></tr><tr><td>I</td><td>倒转排序</td></tr><tr><td>K</td><td>显示/隐藏内核线程</td></tr><tr><td>M</td><td>按内存占用排序</td></tr><tr><td>P</td><td>按CPU排序</td></tr><tr><td>T</td><td>按运行时间排序</td></tr></tbody></table><p>htop的左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面是进程实时状态。<br>最后一行是F1～F10的功能菜单和对应的字符快捷键。</p><h2 id="6-linux系统性能分析"><a href="#6-linux系统性能分析" class="headerlink" title="6. linux系统性能分析"></a>6. linux系统性能分析</h2><p>分析次序为cpu mem disk network</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-nmon软件&quot;&gt;&lt;a href=&quot;#1-nmon软件&quot; class=&quot;headerlink&quot; title=&quot;1. nmon软件&quot;&gt;&lt;/a&gt;1. nmon软件&lt;/h2&gt;&lt;h3 id=&quot;1-1-运行nmon软件&quot;&gt;&lt;a href=&quot;#1-1-运行nmon软件&quot; c
      
    
    </summary>
    
    
      <category term="linux" scheme="http://niuzhiqiang90.coding.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python字符串处理</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/23/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/23/python字符串处理/</id>
    <published>2017-03-23T13:49:45.000Z</published>
    <updated>2017-03-23T14:29:58.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-字符串处理函数"><a href="#1-字符串处理函数" class="headerlink" title="1. 字符串处理函数"></a>1. 字符串处理函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>s.find(substring,[start[,end]])</td><td>查找子字符串，可以指定开始结束的位置，返回索引值，否则返回-1</td></tr><tr><td>s.rfind(substring,[start[,end]])</td><td>反向查找字符串</td></tr><tr><td>s.index(substring,[start[,end]])</td><td>同find，找不到产生ValueError异常</td></tr><tr><td>s.rindex(substring,[start[,end]])</td><td>同反向查找</td></tr><tr><td>s.count(substring,[start[,end]])</td><td>返回找到子串的个数</td></tr><tr><td>s.lowercase()</td><td>所有字符转换成小写</td></tr><tr><td>s.capitalize()</td><td>首字母转换成大写</td></tr><tr><td>s.lower()</td><td>所有字符转换成小写</td></tr><tr><td>s.upper()</td><td>所有字符转换成大写</td></tr><tr><td>s.swapcase()</td><td>大小写互换</td></tr><tr><td>s.split(str,’’)</td><td>将string转换成list，以空格分割</td></tr><tr><td>s.join(list,’’)</td><td>将list转换成string,以空格连接</td></tr></tbody></table><p><strong>处理字符串的内置函数</strong></p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>len(str)</td><td>串长度</td></tr><tr><td>cmp(‘first_str’,str)</td><td>字符串比较，第一个大，返回1</td></tr><tr><td>max(‘string’)</td><td>寻找字符串中最大的字符</td></tr><tr><td>min(‘string’)</td><td>寻找字符串中最小的字符</td></tr></tbody></table><h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><h3 id="2-1-查找子字符串"><a href="#2-1-查找子字符串" class="headerlink" title="2.1 查找子字符串"></a>2.1 查找子字符串</h3><p><code>s.find()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string = &quot;this is the test string&quot;</span><br><span class="line">&gt;&gt;&gt; string.find(&apos;test&apos;)</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="2-2-查找子字符串"><a href="#2-2-查找子字符串" class="headerlink" title="2.2 查找子字符串"></a>2.2 查找子字符串</h3><p><code>s.index()</code><br>找不到就报错，找到就返回索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string = &quot;this is the test string&quot;</span><br><span class="line">&gt;&gt;&gt; string.index(&apos;error&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: substring not found</span><br><span class="line">&gt;&gt;&gt; string.index(&apos;test&apos;)</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><h3 id="2-3-首字母转换成大写"><a href="#2-3-首字母转换成大写" class="headerlink" title="2.3 首字母转换成大写"></a>2.3 首字母转换成大写</h3><p><code>s.capitalize()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string = &quot;this is the test string&quot;</span><br><span class="line">&gt;&gt;&gt; string.capitalize()</span><br><span class="line">&apos;This is the test string&apos;</span><br></pre></td></tr></table></figure><h3 id="2-4-字符串转换成大写"><a href="#2-4-字符串转换成大写" class="headerlink" title="2.4 字符串转换成大写"></a>2.4 字符串转换成大写</h3><p><code>s.upper()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string.upper()</span><br><span class="line">&apos;THIS IS THE TEST STRING&apos;</span><br></pre></td></tr></table></figure><h3 id="2-5-字符串转换成小写"><a href="#2-5-字符串转换成小写" class="headerlink" title="2.5 字符串转换成小写"></a>2.5 字符串转换成小写</h3><p><code>s.lower()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string.lower()</span><br><span class="line">&apos;this is the test string&apos;</span><br></pre></td></tr></table></figure><h3 id="2-6-大小写互换"><a href="#2-6-大小写互换" class="headerlink" title="2.6 大小写互换"></a>2.6 大小写互换</h3><p><code>s.swapcase()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string += &quot;THIS IS CAP&quot;</span><br><span class="line">&gt;&gt;&gt; string</span><br><span class="line">&apos;this is the test stringTHIS IS CAP&apos;</span><br><span class="line">&gt;&gt;&gt; string.swapcase()</span><br><span class="line">&apos;THIS IS THE TEST STRINGthis is cap&apos;</span><br></pre></td></tr></table></figure><h3 id="2-7-将string转换为list"><a href="#2-7-将string转换为list" class="headerlink" title="2.7 将string转换为list"></a>2.7 将string转换为list</h3><p><code>s.split()</code><br>默认为空格，可以指定分隔符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string.split()</span><br><span class="line">[&apos;this&apos;, &apos;is&apos;, &apos;the&apos;, &apos;test&apos;, &apos;stringTHIS&apos;, &apos;IS&apos;, &apos;CAP&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="2-8-将list转换为string"><a href="#2-8-将list转换为string" class="headerlink" title="2.8 将list转换为string"></a>2.8 将list转换为string</h3><p><code>s.join()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;|&apos;.join(string.split())</span><br><span class="line">&apos;this|is|the|test|stringTHIS|IS|CAP&apos;</span><br></pre></td></tr></table></figure></p><p><strong>拓展</strong><br><code>+=</code>和<code>.join</code>实现的效果是一样的，但是<code>+=</code>每次都会新开辟空间，但是<code>.join</code>不用<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;the&apos;</span><br><span class="line">&gt;&gt;&gt; a += &apos; test&apos;</span><br><span class="line">&gt;&gt;&gt; a += &apos; is&apos;</span><br><span class="line">&gt;&gt;&gt; a += &apos; end&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;the test is end&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &apos;&apos;.join(a)</span><br><span class="line">&apos;the test is end&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-字符串处理函数&quot;&gt;&lt;a href=&quot;#1-字符串处理函数&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串处理函数&quot;&gt;&lt;/a&gt;1. 字符串处理函数&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th
      
    
    </summary>
    
    
      <category term="python" scheme="http://niuzhiqiang90.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python文件处理</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/22/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/22/python文件处理/</id>
    <published>2017-03-22T12:51:07.000Z</published>
    <updated>2017-03-23T13:49:22.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1. 文件操作"></a>1. 文件操作</h2><p>file(‘文件名’,’操作符’)<br><strong>省略操作符 默认为读</strong></p><table><thead><tr><th>模式</th><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>只读</td><td><code>r</code></td><td>文件必须存在</td></tr><tr><td>只写</td><td><code>w</code></td><td>文件不存在则创建，文件存在则清空文件内容</td></tr><tr><td>追加</td><td><code>a</code></td><td>文件不存在则创建，文件存在则在文件末尾添加内容</td></tr><tr><td>读写</td><td><code>r+</code></td><td></td></tr><tr><td>写读</td><td><code>w+</code></td><td></td></tr><tr><td>追加</td><td><code>a+</code></td></tr></tbody></table><p>在python中，以什么样的方式出来文件是比较重要的，如果你<br><strong>以只读的方式打开文件，那你就不能写操作</strong><br><strong>以只写的方式打开文件，那你就不能读操作</strong><br><strong>以追加的方式打开文件，也应该是不能进行读操作的</strong><br><strong><font color="red">操作完毕，不要忘记关闭文件</font></strong></p><h3 id="1-1-以只读方式打开文件"><a href="#1-1-以只读方式打开文件" class="headerlink" title="1.1 以只读方式打开文件"></a>1.1 以只读方式打开文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = file(&apos;test&apos;,&apos;r&apos;)  #f为该文件对象</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;hello world\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;this is the second line\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure><h3 id="1-2-以只写方式打开文件"><a href="#1-2-以只写方式打开文件" class="headerlink" title="1.2 以只写方式打开文件"></a>1.2 以只写方式打开文件</h3><p><strong>如果文件存在并且有内容，则会把文件之前的内容清除；如果文件不存在。则会创建文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = file(&apos;test&apos;,&apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IOError: File not open for reading</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IOError: File not open for reading</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f.write(&apos;this is the newest line&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; f_read = file(&apos;test&apos;,&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; f_read.read()</span><br><span class="line">&apos;this is the newest line&apos;</span><br><span class="line">&gt;&gt;&gt; f_read.read()</span><br><span class="line">&apos;&apos;</span><br></pre></td></tr></table></figure></p><h3 id="1-3-以追加的方式打开文件"><a href="#1-3-以追加的方式打开文件" class="headerlink" title="1.3 以追加的方式打开文件"></a>1.3 以追加的方式打开文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = file(&apos;test&apos;,&apos;a&apos;) </span><br><span class="line">&gt;&gt;&gt; f.write(&apos;second line&apos;) </span><br><span class="line">&gt;&gt;&gt; f.write(&apos;\nthird line&apos;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个时候，打开文件，刚才写入的内容并没有写入到文件里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f_read = file(&apos;test&apos;,&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; f_read.readline()</span><br><span class="line">&apos;this is the newest line&apos;</span><br></pre></td></tr></table></figure></p><p><strong>文件在关闭的时候才会写入到文件里</strong>或者<strong>强制写入</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.flush()</span><br></pre></td></tr></table></figure></p><p>追加模式也不可以读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IOError: File not open for reading</span><br></pre></td></tr></table></figure></p><p><strong>拓展</strong></p><ol><li><p>去掉换行符<br><code>line.strip(&#39;换行符&#39;)</code><br>省略换行符默认为空格</p></li><li><p>把行分割<br><code>line.split(&#39;分隔符&#39;)</code></p></li></ol><h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><h3 id="2-1-读取-etc-passwd的内容"><a href="#2-1-读取-etc-passwd的内容" class="headerlink" title="2.1 读取/etc/passwd的内容"></a>2.1 读取<code>/etc/passwd</code>的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = file(&apos;/etc/passwd&apos;)</span><br><span class="line">for line in f.readlines(): #循环文件的每一行 </span><br><span class="line">    line = line.strip(&apos;\n&apos;).split(&apos;:&apos;) </span><br><span class="line">    print line</span><br></pre></td></tr></table></figure><p>得到的结果如下<strong>一个列表</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&apos;root&apos;, &apos;x&apos;, &apos;0&apos;, &apos;0&apos;, &apos;root&apos;, &apos;/root&apos;, &apos;/bin/bash&apos;]</span><br><span class="line">[&apos;daemon&apos;, &apos;x&apos;, &apos;1&apos;, &apos;1&apos;, &apos;daemon&apos;, &apos;/usr/sbin&apos;, &apos;/usr/sbin/nologin&apos;]</span><br><span class="line">[&apos;bin&apos;, &apos;x&apos;, &apos;2&apos;, &apos;2&apos;, &apos;bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin/nologin&apos;]</span><br><span class="line">[&apos;sys&apos;, &apos;x&apos;, &apos;3&apos;, &apos;3&apos;, &apos;sys&apos;, &apos;/dev&apos;, &apos;/usr/sbin/nologin&apos;]</span><br><span class="line">[&apos;sync&apos;, &apos;x&apos;, &apos;4&apos;, &apos;65534&apos;, &apos;sync&apos;, &apos;/bin&apos;, &apos;/bin/sync&apos;]</span><br><span class="line">[&apos;games&apos;, &apos;x&apos;, &apos;5&apos;, &apos;60&apos;, &apos;games&apos;, &apos;/usr/games&apos;, &apos;/usr/sbin/nologin&apos;]</span><br><span class="line">[&apos;man&apos;, &apos;x&apos;, &apos;6&apos;, &apos;12&apos;, &apos;man&apos;, &apos;/var/cache/man&apos;, &apos;/usr/sbin/nologin&apos;]</span><br></pre></td></tr></table></figure></p><p>打印第1列，第2列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print line[0],line[1]</span><br></pre></td></tr></table></figure></p><h3 id="2-2-写文件"><a href="#2-2-写文件" class="headerlink" title="2.2 写文件"></a>2.2 写文件</h3><p>语言本身不存在文件保护的设置，避免多个程序对同一个文件进行操作，需要自己来完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.closed</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p><p><strong>如果<code>f.closed</code>值为False,说明文件已经被打开</strong></p><p>显示文件的字符集，默认为ASCII<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.encoding</span><br><span class="line">&gt;&gt;&gt; print f.encoding</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = file(&apos;test_coding&apos;,&apos;w&apos;) </span><br><span class="line">&gt;&gt;&gt; f.write(u&apos;测试文件编码&apos;) </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-5: ordinal not in range(128)</span><br><span class="line">&gt;&gt;&gt; f.write(u&apos;测试文件编码&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">&gt;&gt;&gt; f.flush()</span><br></pre></td></tr></table></figure><p>读到末尾，<code>next()</code>会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = file(&apos;test_coding&apos;,&apos;r&apos;) </span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;&apos;</span><br><span class="line">&gt;&gt;&gt; f.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3-文件操作相关方法"><a href="#3-文件操作相关方法" class="headerlink" title="3. 文件操作相关方法"></a>3. 文件操作相关方法</h2><p>readline是通过next实现的</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>f.readlines()</td><td>以列表的形式读出文件</td></tr><tr><td>f.read()</td><td>以字符串的形式，一次性读出文件</td></tr><tr><td>f.seek()</td><td>跳到文件的指定位置</td></tr><tr><td>f.tell()</td><td>当前位置</td></tr><tr><td>f.truncate(100)</td><td>从头开始截断文件</td></tr><tr><td>f.writelines()</td><td>多行写</td></tr><tr><td>f.xreadlines()</td><td>逐行读</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-文件操作&quot;&gt;&lt;a href=&quot;#1-文件操作&quot; class=&quot;headerlink&quot; title=&quot;1. 文件操作&quot;&gt;&lt;/a&gt;1. 文件操作&lt;/h2&gt;&lt;p&gt;file(‘文件名’,’操作符’)&lt;br&gt;&lt;strong&gt;省略操作符 默认为读&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="http://niuzhiqiang90.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>git tag操作</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/22/git-tag%E6%93%8D%E4%BD%9C/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/22/git-tag操作/</id>
    <published>2017-03-22T05:17:19.000Z</published>
    <updated>2018-03-22T22:58:30.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-显示本地tag"><a href="#1-显示本地tag" class="headerlink" title="1. 显示本地tag"></a>1. 显示本地tag</h1><p>不带任何参数执行git tag，即可显示当前版本库里的tag列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p><p>显示说明 <code>-n&lt;num&gt;</code> 显示最多num行的说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -n1</span><br></pre></td></tr></table></figure></p><p>只显示名称和通配符相符的tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l string*</span><br></pre></td></tr></table></figure></p><h1 id="2-创建tag"><a href="#2-创建tag" class="headerlink" title="2. 创建tag"></a>2. 创建tag</h1><h2 id="2-1-创建轻量级里程碑"><a href="#2-1-创建轻量级里程碑" class="headerlink" title="2.1 创建轻量级里程碑"></a>2.1 创建轻量级里程碑</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tagname&gt; [&lt;commitID&gt;]</span><br></pre></td></tr></table></figure><h2 id="2-2-创建带说明的tag"><a href="#2-2-创建带说明的tag" class="headerlink" title="2.2 创建带说明的tag"></a>2.2 创建带说明的tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; [&lt;commitID&gt;]</span><br><span class="line">或</span><br><span class="line">git tag -m &lt;msg&gt; &lt;tagname&gt; [&lt;commitID&gt;] //直接通过-m参数提供tag说明</span><br></pre></td></tr></table></figure><h2 id="2-3-创建带GnuPG签名的tag"><a href="#2-3-创建带GnuPG签名的tag" class="headerlink" title="2.3 创建带GnuPG签名的tag"></a>2.3 创建带GnuPG签名的tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; [&lt;commitID&gt;]</span><br><span class="line">或</span><br><span class="line">git tag -u &lt;key-id&gt;  &lt;tagname&gt; [&lt;commitID&gt;] //-u参数选择指定的私钥进行签名</span><br></pre></td></tr></table></figure><p>创建tag需要输入tag的名称(<tagname>)和一个可选的提交ID(<commitid>)。<font color="red">如果没有提供提交ID，则基于头指针HEAD创建tag。</font></commitid></tagname></p><h1 id="3-删除tag"><a href="#3-删除tag" class="headerlink" title="3. 删除tag"></a>3. 删除tag</h1><p>本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure></p><p>远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete tag &lt;tagname&gt;</span><br><span class="line">或</span><br><span class="line">git tag -d &lt;tagname&gt; </span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;  #推送一个空tag到远程</span><br></pre></td></tr></table></figure></p><h1 id="4-提交tag"><a href="#4-提交tag" class="headerlink" title="4. 提交tag"></a>4. 提交tag</h1><p>提交单个tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line">或</span><br><span class="line">git push tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure></p><p>提交所有tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br><span class="line">或</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-显示本地tag&quot;&gt;&lt;a href=&quot;#1-显示本地tag&quot; class=&quot;headerlink&quot; title=&quot;1. 显示本地tag&quot;&gt;&lt;/a&gt;1. 显示本地tag&lt;/h1&gt;&lt;p&gt;不带任何参数执行git tag，即可显示当前版本库里的tag列表&lt;br&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="git" scheme="http://niuzhiqiang90.coding.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>python用户交互</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/20/python%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/20/python用户交互/</id>
    <published>2017-03-20T14:05:30.000Z</published>
    <updated>2017-03-21T13:16:24.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-raw-input"><a href="#1-raw-input" class="headerlink" title="1. raw_input()"></a>1. raw_input()</h2><p>raw_input() 从标准输入中读取一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">raw_input(...)</span><br><span class="line">    raw_input([prompt]) -&gt; string</span><br><span class="line">    </span><br><span class="line">    Read a string from standard input.  The trailing newline is stripped.</span><br><span class="line">    If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.</span><br><span class="line">    On Unix, GNU readline is used if enabled.  The prompt string, if given,</span><br><span class="line">    is printed without a trailing newline before reading.</span><br></pre></td></tr></table></figure></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = raw_input(&apos;Please input your name:&apos;)</span><br><span class="line">age = raw_input(&apos;age:&apos;)</span><br><span class="line">print &quot;name: &quot; % name</span><br><span class="line">print &quot;age:&quot; % age</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">name = raw_input(&apos;Please input your name:&apos;)</span><br><span class="line">age = raw_input(&apos;age:&apos;)</span><br><span class="line">job = raw_input(&apos;Job:&apos;)</span><br><span class="line">salary = raw_input(&apos;Salary:&apos;)</span><br><span class="line"></span><br><span class="line">print &apos;&apos;&apos;</span><br><span class="line">Personal information of %s:</span><br><span class="line">   Name : %s</span><br><span class="line">   Age  : %s     d只能输入数字 f只能输入浮点型</span><br><span class="line">    Job : %s</span><br><span class="line">  Salary: %s</span><br><span class="line">&apos;&apos;&apos; %(name, name, age, job, salary)</span><br></pre></td></tr></table></figure><h2 id="2-input"><a href="#2-input" class="headerlink" title="2. input()"></a>2. input()</h2><p>input()    输入的是什么就是什么格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input(...)</span><br><span class="line">    input([prompt]) -&gt; value</span><br><span class="line">    </span><br><span class="line">    Equivalent to eval(raw_input(prompt)).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; info = &quot;This var will be printed out ...&quot;</span><br><span class="line">&gt;&gt;&gt; age = input(&apos;age:&apos;)</span><br><span class="line">age:info</span><br><span class="line">&gt;&gt;&gt; print age</span><br><span class="line">This var will be printed out ...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-raw-input&quot;&gt;&lt;a href=&quot;#1-raw-input&quot; class=&quot;headerlink&quot; title=&quot;1. raw_input()&quot;&gt;&lt;/a&gt;1. raw_input()&lt;/h2&gt;&lt;p&gt;raw_input() 从标准输入中读取一个字符串&lt;br
      
    
    </summary>
    
    
      <category term="python" scheme="http://niuzhiqiang90.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python使用和导入模块</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/20/python%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/20/python使用和导入模块/</id>
    <published>2017-03-20T13:47:06.000Z</published>
    <updated>2017-03-21T13:16:24.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-导入模块的方法"><a href="#1-导入模块的方法" class="headerlink" title="1. 导入模块的方法"></a>1. 导入模块的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import moduleName 导入模块</span><br><span class="line">From module import sayHi  从模块导入某个具体的方法</span><br><span class="line">import moduleName as newName  给模块起别名</span><br><span class="line">from sys import *   导入模块下的所有方法</span><br></pre></td></tr></table></figure><ul><li><p>给模块起别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing as multi</span><br></pre></td></tr></table></figure></li><li><p>把模块下所有的方法导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sys import *</span><br><span class="line">&gt;&gt;&gt; print path</span><br><span class="line">[&apos;&apos;, &apos;/usr/lib/python2.7&apos;, &apos;/usr/lib/python2.7/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python2.7/lib-tk&apos;, &apos;/usr/lib/python2.7/lib-old&apos;, &apos;/usr/lib/python2.7/lib-dynload&apos;, &apos;/usr/local/lib/python2.7/dist-packages&apos;, &apos;/usr/lib/python2.7/dist-packages&apos;, &apos;/usr/lib/python2.7/dist-packages/PILcompat&apos;, &apos;/usr/lib/python2.7/dist-packages/gtk-2.0&apos;, &apos;/usr/lib/pymodules/python2.7&apos;, &apos;/usr/lib/python2.7/dist-packages/ubuntu-sso-client&apos;]</span><br></pre></td></tr></table></figure></li></ul><font color="red">不建议使用<code>from sys import *</code> 可能被自定义的变量覆盖 调用时加上模块名 <code>sys.argv[2]</code> 可防止 </font><h2 id="2-系统命令交互模块"><a href="#2-系统命令交互模块" class="headerlink" title="2. 系统命令交互模块"></a>2. 系统命令交互模块</h2><h3 id="2-1-os模块"><a href="#2-1-os模块" class="headerlink" title="2.1 os模块"></a>2.1 os模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.system(&apos;pwd&apos;)</span><br><span class="line">/home/niuzhiqiang/Desktop</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; cur_dir = os.system(&apos;pwd&apos;)</span><br><span class="line">/home/xxx/Desktop</span><br><span class="line">&gt;&gt;&gt; print cur_dir</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; os.popen(&apos;pwd&apos;)</span><br><span class="line">&lt;open file &apos;pwd&apos;, mode &apos;r&apos; at 0x7f9017578c90&gt;</span><br><span class="line">&gt;&gt;&gt; cur_dir = os.popen(&apos;pwd&apos;).read()</span><br><span class="line">&gt;&gt;&gt; print cur_dir</span><br><span class="line">/home/xxx/Desktop</span><br></pre></td></tr></table></figure><p><strong>例：循环列出目录下的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.walk(&apos;/the/directory/&apos;)</span><br><span class="line">&gt;&gt;&gt; os.next()</span><br><span class="line">&gt;&gt;&gt; os.next()</span><br></pre></td></tr></table></figure><h3 id="2-2-commands模块"><a href="#2-2-commands模块" class="headerlink" title="2.2 commands模块"></a>2.2 commands模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import commands</span><br><span class="line">&gt;&gt;&gt; res = commands.getstatusoutput(&apos;pwd&apos;)</span><br><span class="line">&gt;&gt;&gt; print res</span><br><span class="line">(0, &apos;/home/xxx/Desktop&apos;)</span><br><span class="line">&gt;&gt;&gt; print res[1]</span><br><span class="line">/home/xxx/Desktop</span><br></pre></td></tr></table></figure><h3 id="2-3-subprocess模块"><a href="#2-3-subprocess模块" class="headerlink" title="2.3 subprocess模块"></a>2.3 subprocess模块</h3><p>todo</p><h3 id="2-4-sys模块"><a href="#2-4-sys模块" class="headerlink" title="2.4 sys模块"></a>2.4 sys模块</h3><p>取程序的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print sys.argv</span><br><span class="line">print sys.argv[2]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import argv</span><br><span class="line"># 不需要使用`sys.`</span><br><span class="line">print argv</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-导入模块的方法&quot;&gt;&lt;a href=&quot;#1-导入模块的方法&quot; class=&quot;headerlink&quot; title=&quot;1. 导入模块的方法&quot;&gt;&lt;/a&gt;1. 导入模块的方法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="http://niuzhiqiang90.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python字符编码</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/20/python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/20/python字符编码/</id>
    <published>2017-03-20T13:20:21.000Z</published>
    <updated>2017-03-21T13:16:24.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ASSIC码"><a href="#1-ASSIC码" class="headerlink" title="1. ASSIC码"></a>1. ASSIC码</h2><p>一共规定了128个字符的编码</p><h3 id="1-1-ord函数"><a href="#1-1-ord函数" class="headerlink" title="1.1 ord函数"></a>1.1 ord函数</h3><p><code>ord(&#39;single-char&#39;)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ord(...)</span><br><span class="line">    ord(c) -&gt; integer</span><br><span class="line">    </span><br><span class="line">    Return the integer ordinal of a one-character string.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;a&apos;)</span><br><span class="line">97</span><br><span class="line">&gt;&gt;&gt; type(ord(&apos;a&apos;))</span><br><span class="line">&lt;type &apos;int&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &apos;Hello World&apos;</span><br><span class="line">for i in string:</span><br><span class="line">    print ord(i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &apos;Hello World&apos;</span><br><span class="line">list_ascii = [ord(i) for i in string]</span><br><span class="line">print list_ascii</span><br></pre></td></tr></table></figure><h3 id="1-2-chr函数"><a href="#1-2-chr函数" class="headerlink" title="1.2 chr函数"></a>1.2 chr函数</h3><p><code>chr(number)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chr(...)</span><br><span class="line">    chr(i) -&gt; character</span><br><span class="line">        </span><br><span class="line">            Return a string of one character with ordinal i; 0 &lt;= i &lt; 256.</span><br></pre></td></tr></table></figure><h2 id="2-Unicode编码"><a href="#2-Unicode编码" class="headerlink" title="2. Unicode编码"></a>2. Unicode编码</h2><p>16位 可以存下汉字</p><h3 id="2-1-默认编码是ASCII"><a href="#2-1-默认编码是ASCII" class="headerlink" title="2.1 默认编码是ASCII"></a>2.1 默认编码是ASCII</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;hello&apos;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;hello&apos;</span><br></pre></td></tr></table></figure><h3 id="2-2-加u则指定为Unicode"><a href="#2-2-加u则指定为Unicode" class="headerlink" title="2.2 加u则指定为Unicode"></a>2.2 加<code>u</code>则指定为Unicode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = u&apos;hello&apos;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;unicode&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">u&apos;hello&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b=u&apos;你好&apos;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">u&apos;\u4f60\u597d&apos;</span><br><span class="line">&gt;&gt;&gt; len(b)</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="3-UTF-8编码"><a href="#3-UTF-8编码" class="headerlink" title="3. UTF-8编码"></a>3. UTF-8编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 转换成utf-8</span><br><span class="line">&gt;&gt;&gt; b.encode(&apos;utf-8&apos;)</span><br><span class="line">&apos;\xe4\xbd\xa0\xe5\xa5\xbd&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; b_utf8 = b.encode(&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; len(b_utf8)</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="4-Unicode和UTF-8的转换"><a href="#4-Unicode和UTF-8的转换" class="headerlink" title="4. Unicode和UTF-8的转换"></a>4. Unicode和UTF-8的转换</h2><h3 id="4-1-Unicode-gt-gt-UTF-8"><a href="#4-1-Unicode-gt-gt-UTF-8" class="headerlink" title="4.1 Unicode &gt;&gt; UTF-8"></a>4.1 Unicode &gt;&gt; UTF-8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.encode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b=u&apos;你好&apos;</span><br><span class="line"># Unicode转换成UTF-8 </span><br><span class="line">&gt;&gt;&gt; b_utf8=b.encode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><h3 id="4-2-UTF-8-gt-gt-Unicode"><a href="#4-2-UTF-8-gt-gt-Unicode" class="headerlink" title="4.2 UTF-8  &gt;&gt; Unicode"></a>4.2 UTF-8  &gt;&gt; Unicode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_utf8.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b_utf8</span><br><span class="line">&apos;\xe4\xbd\xa0\xe5\xa5\xbd&apos;</span><br><span class="line">&gt;&gt;&gt; b_utf8.decode(&apos;utf-8&apos;)</span><br><span class="line">u&apos;\u4f60\u597d&apos;</span><br></pre></td></tr></table></figure><h2 id="5-指定程序的编码方式"><a href="#5-指定程序的编码方式" class="headerlink" title="5. 指定程序的编码方式"></a>5. 指定程序的编码方式</h2><p>程序如果有中文,需要指定编码方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#_*_ coding:utf-8 _*_</span><br><span class="line"></span><br><span class="line">name = u&apos;中文&apos;</span><br><span class="line">print name</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-ASSIC码&quot;&gt;&lt;a href=&quot;#1-ASSIC码&quot; class=&quot;headerlink&quot; title=&quot;1. ASSIC码&quot;&gt;&lt;/a&gt;1. ASSIC码&lt;/h2&gt;&lt;p&gt;一共规定了128个字符的编码&lt;/p&gt;
&lt;h3 id=&quot;1-1-ord函数&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="python" scheme="http://niuzhiqiang90.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ceph</title>
    <link href="http://niuzhiqiang90.coding.me/2017/03/13/ceph/"/>
    <id>http://niuzhiqiang90.coding.me/2017/03/13/ceph/</id>
    <published>2017-03-13T13:13:03.000Z</published>
    <updated>2017-06-04T13:38:04.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ceph的搭建"><a href="#ceph的搭建" class="headerlink" title="ceph的搭建"></a>ceph的搭建</h1><p><strong>注</strong> 如果在安装过程中，想要重新安装，需要执行如下命令清除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo stop ceph-all  #停止所有CEPH进程</span><br><span class="line">ceph-deploy uninstall  [&#123;ceph-node&#125;]   #卸载所有ceph程序</span><br><span class="line">ceph-deploy purge   [[ceph-node&#125; [&#123;ceph-node&#125;] #删除ceph相关的包</span><br><span class="line">ceph-deploy purgedata &#123;ceph-node&#125; [&#123;ceph-node&#125;]   #删除ceph相关的包</span><br><span class="line">ceph-deploy forgetkeys #删除key</span><br></pre></td></tr></table></figure></p><h2 id="1-安装前准备"><a href="#1-安装前准备" class="headerlink" title="1. 安装前准备"></a>1. 安装前准备</h2><h3 id="1-1-添加hosts解析"><a href="#1-1-添加hosts解析" class="headerlink" title="1.1 添加hosts解析"></a>1.1 添加hosts解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br><span class="line"></span><br><span class="line"># 添加如下内容</span><br><span class="line">192.168.1.174node1</span><br><span class="line">192.168.1.175node2</span><br></pre></td></tr></table></figure><p><strong>注:  <font color="red">node1 node2必须为hostname，因为在安装过程中会验证hostname是否为node{1,2}<br>遇到这个错误，需要完全清理ceph软件和配置数据，从头再来<br></font></strong></p><h3 id="1-2-免密码登录"><a href="#1-2-免密码登录" class="headerlink" title="1.2 免密码登录"></a>1.2 免密码登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 生成密钥对</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"># admin节点需要通过密钥对登录到其他节点</span><br><span class="line">ssh-copy-id ceph@node1</span><br><span class="line">ssh-copy-id ceph@node2</span><br></pre></td></tr></table></figure><p>在<strong>每个Ceph节点</strong>中为用户增加 root 权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ceph ALL = (root) NOPASSWD:ALL&quot; | sudo tee /etc/sudoers.d/ceph</span><br><span class="line">sudo chmod 0440 /etc/sudoers.d/ceph</span><br></pre></td></tr></table></figure></p><h3 id="1-3-安装ceph-deploy软件"><a href="#1-3-安装ceph-deploy软件" class="headerlink" title="1.3 安装ceph-deploy软件"></a>1.3 安装ceph-deploy软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># 添加Ceph软件包源，用Ceph稳定版（如cuttlefish 、 dumpling 、 emperor 、 firefly 等等）替换掉 &#123;ceph-stable-release&#125;</span><br><span class="line"># echo deb http://download.ceph.com/debian-&#123;ceph-stable-release&#125;/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</span><br><span class="line"># 例如：</span><br><span class="line">echo deb http://download.ceph.com/debian-dumpling/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ceph-deploy</span><br></pre></td></tr></table></figure><h2 id="2-创建ceph目录"><a href="#2-创建ceph目录" class="headerlink" title="2. 创建ceph目录"></a>2. 创建ceph目录</h2><p>我们使用ceph-deploy部署，<strong>后续操作均在admin节点操作</strong>。<br>首先需要创建工作环境，该环境会保存所有的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir opt/ceph</span><br><span class="line">cd opt/ceph</span><br></pre></td></tr></table></figure></p><h2 id="3-创建集群"><a href="#3-创建集群" class="headerlink" title="3. 创建集群"></a>3. 创建集群</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy new node1</span><br></pre></td></tr></table></figure><p>其中node1是mon节点，执行该命令会生成ceph配置文件、monitor密钥文件以及日志文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ls</span><br><span class="line">ceph.conf  ceph.log  ceph.mon.keyring</span><br></pre></td></tr></table></figure></p><h2 id="4-修改默认冗余份数"><a href="#4-修改默认冗余份数" class="headerlink" title="4. 修改默认冗余份数"></a>4. 修改默认冗余份数</h2><h3 id="4-1-设置osd冗余份数"><a href="#4-1-设置osd冗余份数" class="headerlink" title="4.1 设置osd冗余份数"></a>4.1 设置osd冗余份数</h3><p>由于我们目前只有两个osd节点，而默认的冗余份数是3，因此我们需要设置为2，如果osd节点大于2，则此步骤省略。<br>修改ceph.conf文件，在[global]下增加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ echo &quot;osd pool default size = 2&quot; &gt;&gt; ceph.conf</span><br></pre></td></tr></table></figure></p><p><strong>如果有多块网卡需要配置使用哪块网卡</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon_host = `对应网卡的IP地址`</span><br></pre></td></tr></table></figure></p><h3 id="4-2-在节点上安装ceph软件"><a href="#4-2-在节点上安装ceph软件" class="headerlink" title="4.2 在节点上安装ceph软件"></a>4.2 在节点上安装ceph软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy install node1 node2</span><br></pre></td></tr></table></figure><p>如果失败会报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[node1][ERROR ] RuntimeError: command returned non-zero exit status: 100</span><br><span class="line">[ceph_deploy][ERROR ] RuntimeError: Failed to execute command: apt-get -q update</span><br></pre></td></tr></table></figure></p><p><strong>解决方法</strong></p><ul><li><p>1.同步配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ rsync -avz ../ceph ceph@node2:~/opt/</span><br></pre></td></tr></table></figure></li><li><p>2.在<font color="red">所有节点</font>分别安装ceph</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ sudo apt-get install ceph</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-初始化mon节点和收集密钥信息"><a href="#5-初始化mon节点和收集密钥信息" class="headerlink" title="5. 初始化mon节点和收集密钥信息"></a>5. 初始化mon节点和收集密钥信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure><p>如果报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[node1][DEBUG ] get remote short hostname</span><br><span class="line">[node1][WARNIN] ********************************************************************************</span><br><span class="line">[node1][WARNIN] provided hostname must match remote hostname</span><br><span class="line">[node1][WARNIN] provided hostname: node1</span><br><span class="line">[node1][WARNIN] remote hostname: ubuntu</span><br><span class="line">[node1][WARNIN] monitors may not reach quorum and create-keys will not complete</span><br></pre></td></tr></table></figure></p><p>因为/etc/hosts中解析的<code>ip地址 主机名</code>和远端的主机名不匹配所致，在/etc/hosts中修改为正确的hostname，清理下从头重新安装。</p><p>执行完毕，目录应该有以下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;cluster-name&#125;.client.admin.keyring</span><br><span class="line">&#123;cluster-name&#125;.bootstrap-osd.keyring</span><br><span class="line">&#123;cluster-name&#125;.bootstrap-mds.keyring</span><br><span class="line">&#123;cluster-name&#125;.bootstrap-rgw.keyring</span><br></pre></td></tr></table></figure></p><h2 id="6-配置osd节点"><a href="#6-配置osd节点" class="headerlink" title="6. 配置osd节点"></a>6. 配置osd节点</h2><p>首先格式化磁盘，注意我们使用的是/dev/sdb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy disk zap node1:sdb</span><br><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy disk zap node2:sdb</span><br></pre></td></tr></table></figure></p><p>以上步骤会<font color="red">清空磁盘的所有数据</font>。</p><p>接下来创建osd，注意由于我们只是测试，故没有使用单独的磁盘作为journal<br>(todo分析具体什么)<br>实际在生产环境下，需要配备SSD分区作为journal，能够最大化IO吞吐量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy osd create node1:sdb</span><br><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy osd create node2:sdb</span><br></pre></td></tr></table></figure></p><p>在节点上执行<code>df -h</code>会得到如下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdb1        35G   36M   35G   1% /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure></p><h2 id="7-配置admin节点"><a href="#7-配置admin节点" class="headerlink" title="7. 配置admin节点"></a>7. 配置admin节点</h2><p>admin节点同时也作为我们的client节点，需要拷贝其他节点的配置文件以及密钥，使得不需要指定mon地址以及用户信息就可以直接管理我们的ceph集群，执行以下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-deploy admin node1 node2</span><br><span class="line">ceph@node1:~/opt/ceph$ sudo chmod +r /etc/ceph/ceph.client.admin.keyring # 保证具有读取的密钥的权限</span><br></pre></td></tr></table></figure></p><h2 id="8-测试结果"><a href="#8-测试结果" class="headerlink" title="8. 测试结果"></a>8. 测试结果</h2><p>运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph health</span><br><span class="line">ceph@node1:~/opt/ceph$ ceph -s</span><br></pre></td></tr></table></figure></p><p>结果若返回active + clean状态，则说明部署成功！</p><h2 id="9-配置mds"><a href="#9-配置mds" class="headerlink" title="9. 配置mds"></a>9. 配置mds</h2><p><a href="http://docs.ceph.com/docs/master/install/manual-deployment/#adding-mds" target="_blank" rel="noopener">Adding MDS参考链接</a></p><h3 id="9-1-安装mds"><a href="#9-1-安装mds" class="headerlink" title="9.1 安装mds"></a>9.1 安装mds</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ sudo apt-get install ceph-mds</span><br></pre></td></tr></table></figure><h3 id="9-2-配置"><a href="#9-2-配置" class="headerlink" title="9.2 配置"></a>9.2 配置</h3><p>{id}是一个任意的名字,例如可以是电脑的主机名</p><p>编辑<code>ceph.conf</code>，添加MDS区域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mds]</span><br><span class="line">  mds data = /var/lib/ceph/mds/mds.$id</span><br><span class="line">  keyring = /var/lib/ceph/mds/mds.$id/mds.$id.keyring</span><br><span class="line"></span><br><span class="line">[mds.0] # 0为id</span><br><span class="line">  host = 0 # &#123;id&#125;</span><br></pre></td></tr></table></figure></p><h3 id="9-3-创建目录"><a href="#9-3-创建目录" class="headerlink" title="9.3 创建目录"></a>9.3 创建目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ mkdir -p /var/lib/ceph/mds/&#123;cluster-name&#125;-&#123;id&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-生成keyring"><a href="#9-4-生成keyring" class="headerlink" title="9.4 生成keyring"></a>9.4 生成keyring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-authtool --create-keyring /var/lib/ceph/mds/&#123;cluster-name&#125;-&#123;id&#125;/keyring --gen-key -n mds.&#123;id&#125;</span><br></pre></td></tr></table></figure><p>Import the keyring and set caps.:</p><h3 id="9-5-导入keyring"><a href="#9-5-导入keyring" class="headerlink" title="9.5 导入keyring"></a>9.5 导入keyring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph auth add mds.&#123;id&#125; osd &quot;allow rwx&quot; mds &quot;allow&quot; mon &quot;allow profile mds&quot; -i /var/lib/ceph/mds/&#123;cluster&#125;-&#123;id&#125;/keyring</span><br></pre></td></tr></table></figure><h3 id="9-6-修改配置文件"><a href="#9-6-修改配置文件" class="headerlink" title="9.6 修改配置文件"></a>9.6 修改配置文件</h3><p>Add to ceph.conf.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mds.&#123;id&#125;]</span><br><span class="line">host = &#123;id&#125;</span><br></pre></td></tr></table></figure></p><h3 id="9-7-手动启动"><a href="#9-7-手动启动" class="headerlink" title="9.7 手动启动"></a>9.7 手动启动</h3><p>Start the daemon the manual way.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph-mds --cluster &#123;cluster-name&#125; -i &#123;id&#125; -m &#123;mon-hostname&#125;:&#123;mon-port&#125; [-f]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ service ceph start</span><br><span class="line">ceph@node1:~/opt/ceph$ sudo service ceph start mds</span><br></pre></td></tr></table></figure><p>检查进程是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ps -ef | grep ceph</span><br><span class="line">root      4032     1  0 17:18 ?        00:00:00 /usr/bin/ceph-mon --cluster=ceph -i node1 -f</span><br><span class="line">root      4687     1  0 17:19 ?        00:00:04 /usr/bin/ceph-osd --cluster=ceph -i 0 -f</span><br><span class="line">root      5196     1  0 17:23 ?        00:00:00 ceph-mds --cluster mds -i 0 -m 192.168.1.176:6789</span><br></pre></td></tr></table></figure></p><p>如果已经存在，下面步骤跳过，直接执行第10步的挂载</p><p>如果mds起不来，可以执行如下命令，查看具体报错信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ sudo ceph-mds --cluster node1 -i 0 -m 192.168.1.176:6789 -f</span><br><span class="line">starting mds.0 at :/0</span><br><span class="line">2017-03-13 15:15:49.485908 7f32b07bb800 -1 did not load config file, using default settings.</span><br><span class="line">2017-03-13 15:15:49.488414 7f32b07bb800 -1 monclient(hunting): ERROR: missing keyring, cannot use cephx for authentication</span><br><span class="line">2017-03-13 15:15:49.490934 7f32b07bb800 -1 mds.-1.0 ERROR: failed to authenticate: (95) Operation not supported</span><br></pre></td></tr></table></figure></p><blockquote><p>If starting the daemon fails with this error:<br>mds.-1.0 ERROR: failed to authenticate: (22) Invalid argument<br>Then make sure you do not have a keyring set in ceph.conf in the global section; move it to the client section; or add a keyring setting specific to this mds daemon. And verify that you see the same key in the mds data directory and ceph auth get mds.{id} output.</p></blockquote><p><strong> 检查步骤 </strong><br>查看如下结果是否一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ ceph auth get mds.0</span><br><span class="line">exported keyring for mds.0</span><br><span class="line">[mds.0]</span><br><span class="line">        key = AQBrR8ZY8GN+NxAAVu2pKRH0pXKixwca7HUdjA==</span><br><span class="line">        caps mds = &quot;allow&quot;</span><br><span class="line">        caps mon = &quot;allow profile mds&quot;</span><br><span class="line">        caps osd = &quot;allow rwx&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ceph@node1:~/opt/ceph$ cat /var/lib/ceph/mds/mds-0/keyring</span><br><span class="line">[mds.0]</span><br><span class="line">        key = AQBrR8ZY8GN+NxAAVu2pKRH0pXKixwca7HUdjA==</span><br></pre></td></tr></table></figure></p><p>如果仍然报如上错误，可以尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ sudo chown -R ceph:ceph /var/lib/ceph/mds/mds-0</span><br></pre></td></tr></table></figure></p><p>重新生成认证文件应该就会成功,<font color="red">不过不确定对后续操作的影响</font></p><p><a href="https://www.sebastien-han.fr/blog/2013/05/13/deploy-a-ceph-mds-server/" target="_blank" rel="noopener">也可以尝试这里的步骤，不过不保证会好使</a></p><p>Now you are ready to create a Ceph filesystem.</p><h2 id="10-挂载"><a href="#10-挂载" class="headerlink" title="10. 挂载"></a>10. 挂载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ sudo mkdir /mnt/cephfs</span><br><span class="line">ceph@node1:~/opt/ceph$ sudo ceph-fuse -m &#123;ip-address-of-monitor&#125;:6789 /mnt/cephfs</span><br><span class="line">ceph@node1:~/opt/ceph$ df -h</span><br></pre></td></tr></table></figure><p>在node2上执行 安装ceph-fuse<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ceph@node1:~/opt/ceph$ sudo apt-get install ceph-fuse</span><br><span class="line">ceph@node1:~/opt/ceph$ sudo mkdir /mnt/cephfs</span><br><span class="line">ceph@node1:~/opt/ceph$ sudo ceph-fuse -m &#123;ip-address-of-monitor&#125;:6789 /mnt/cephfs</span><br><span class="line">ceph@node1:~/opt/ceph$ df -h</span><br></pre></td></tr></table></figure></p><h2 id="11-注意事项"><a href="#11-注意事项" class="headerlink" title="11. 注意事项"></a>11. 注意事项</h2><font color="red">用户ceph不能够锁定，为了安全问题，只能将用户ceph改为nologin</font><h2 id="12-服务器重启"><a href="#12-服务器重启" class="headerlink" title="12. 服务器重启"></a>12. 服务器重启</h2><p>服务器重启后，对于mon节点来说<code>osd</code>和<code>mon</code>会自动启动<br>osd节点的osd服务也会自动启动</p><p> mon节点的<code>mds</code>服务需要手动启动，启动方法为<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ceph-mds --cluster &#123;cluster-name&#125; -i &#123;id&#125; -m &#123;mon-hostname&#125;:&#123;mon-port&#125; [-f]</span><br></pre></td></tr></table></figure></p><p> <strong>另</strong><br> 启动完mds后还需要执行挂载命令<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ceph-fuse -m &#123;ip-address-of-monitor&#125;:6789 /mnt/cephfs</span><br></pre></td></tr></table></figure></p><p> 可以将以上命令<strong>放入到开机启动项中</strong>，但是服务器重启完成后要进行检查ceph的运行状态<br> <code>ceph -s</code>或者<code>ps -ef | grep ceph</code> 或者 通过<code>df -h</code>查看ceph-fuse是否成功挂载目录<br> 如果长时间没成功，并且<code>ceph -s</code>报错，可以尝试将另一节点node2也重启，node1可以成功挂载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ceph的搭建&quot;&gt;&lt;a href=&quot;#ceph的搭建&quot; class=&quot;headerlink&quot; title=&quot;ceph的搭建&quot;&gt;&lt;/a&gt;ceph的搭建&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt; 如果在安装过程中，想要重新安装，需要执行如下命令清除&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="ceph" scheme="http://niuzhiqiang90.coding.me/categories/ceph/"/>
    
    
      <category term="ceph" scheme="http://niuzhiqiang90.coding.me/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>docker-registry</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/27/docker-registry/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/27/docker-registry/</id>
    <published>2017-02-27T11:44:00.000Z</published>
    <updated>2017-08-29T15:13:37.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-启动registry"><a href="#1-启动registry" class="headerlink" title="1. 启动registry"></a>1. 启动registry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --name registry registry</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-p 5000:5000</code></td><td>第一个是host的端口，第二个是container的端口</td></tr><tr><td><code>--name registry registry1</code></td><td>registry是镜像名字，registry1是自定义的私有registry名字</td></tr></tbody></table><h2 id="2-测试私有仓库"><a href="#2-测试私有仓库" class="headerlink" title="2. 测试私有仓库"></a>2. 测试私有仓库</h2><h3 id="2-1-新pull一个镜像"><a href="#2-1-新pull一个镜像" class="headerlink" title="2.1 新pull一个镜像"></a>2.1 新pull一个镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull busybox</span><br></pre></td></tr></table></figure><h3 id="2-2-给镜像打个tag"><a href="#2-2-给镜像打个tag" class="headerlink" title="2.2 给镜像打个tag"></a>2.2 给镜像打个tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag busybox xxx.xxx.xxx.xxx:5000/myfirstimage</span><br></pre></td></tr></table></figure><h3 id="2-3-push到私有仓库"><a href="#2-3-push到私有仓库" class="headerlink" title="2.3 push到私有仓库"></a>2.3 push到私有仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push xxx.xxx.xxx.xxx:5000/myfirstimage</span><br></pre></td></tr></table></figure><h3 id="2-4-查看私有镜像仓库中的镜像"><a href="#2-4-查看私有镜像仓库中的镜像" class="headerlink" title="2.4 查看私有镜像仓库中的镜像"></a>2.4 查看私有镜像仓库中的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://xxx.xxx.xxx.xxx:5000/v2/_catalog</span><br></pre></td></tr></table></figure><h3 id="2-5-删除本地的镜像"><a href="#2-5-删除本地的镜像" class="headerlink" title="2.5 删除本地的镜像"></a>2.5 删除本地的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi xxx.xxx.xxx.xxx:5000/myfirstimage</span><br></pre></td></tr></table></figure><h3 id="2-6-将刚才的删除的镜像，从私有镜像仓库pull回来"><a href="#2-6-将刚才的删除的镜像，从私有镜像仓库pull回来" class="headerlink" title="2.6 将刚才的删除的镜像，从私有镜像仓库pull回来"></a>2.6 将刚才的删除的镜像，从私有镜像仓库pull回来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull xxx.xxx.xxx.xxx:5000/myfirstimage</span><br></pre></td></tr></table></figure><h2 id="3-报错及处理"><a href="#3-报错及处理" class="headerlink" title="3. 报错及处理"></a>3. 报错及处理</h2><h3 id="3-1-在本地push时，出现如下错误"><a href="#3-1-在本地push时，出现如下错误" class="headerlink" title="3.1 在本地push时，出现如下错误"></a>3.1 在本地push时，出现如下错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push xxx.xxx.xxx.xxx:5000/myfirstimage</span><br><span class="line">The push refers to a repository [xxx.xxx.xxx.xxx:5000/myfirstimage]</span><br><span class="line">Get https://xxx.xxx.xxx.xxx:5000/v1/_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ol><li><p>修改配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/default/docker</span><br></pre></td></tr></table></figure></li><li><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;--insecure-registry xxx.xxx.xxx.xxx:5000&quot;</span><br></pre></td></tr></table></figure></li><li><p>重启docker服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure></li><li><p>重新执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push xxx.xxx.xxx.xxx:5000/myfirstimage</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-启动registry&quot;&gt;&lt;a href=&quot;#1-启动registry&quot; class=&quot;headerlink&quot; title=&quot;1. 启动registry&quot;&gt;&lt;/a&gt;1. 启动registry&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://niuzhiqiang90.coding.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/27/docker%E5%AE%B9%E5%99%A8/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/27/docker容器/</id>
    <published>2017-02-27T09:26:49.000Z</published>
    <updated>2017-03-13T13:34:57.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-新建并启动容器"><a href="#1-新建并启动容器" class="headerlink" title="1. 新建并启动容器"></a>1. 新建并启动容器</h2><p><code>docker run</code><br>例：下面的命令输出一个“Hello World”并终止容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run ubuntu:14.04 /bin/echo &apos;Hello World&apos;</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>启动一个bash终端并允许交互<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@3060c837bd2d:/#</span><br></pre></td></tr></table></figure></p><p><code>-t</code>让docker分配一个伪终端并绑定到容器的标准输入上，<code>-i</code>则让容器的标准输入保持打开。</p><h2 id="2-启动已终止的容器"><a href="#2-启动已终止的容器" class="headerlink" title="2. 启动已终止的容器"></a>2. 启动已终止的容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a 找到容器ID</span><br><span class="line">sudo docker start CONTAINER_ID</span><br></pre></td></tr></table></figure><h2 id="3-守护态运行"><a href="#3-守护态运行" class="headerlink" title="3. 守护态运行"></a>3. 守护态运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br></pre></td></tr></table></figure><p>在使用<code>-d</code>参数时,容器启动后会进入后台。某些时候需要进入容器进行操作,有很多种方法,包括使用<code>docker attach</code>命令或nsenter工具等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES</span><br><span class="line">428e85fb5182        ubuntu:12.04        &quot;/bin/sh -c &apos;while t   3 minutes ago       Up 3 minutes                            pensive_kirch       </span><br><span class="line">ubuntu@ubuntu:~$ sudo docker attach 428e85fb5182</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">^Cubuntu@ubuntu:~$ </span><br><span class="line">ubuntu@ubuntu:~$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure></p><p>获取容器的输出信息，可以通过<code>docker log</code>命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs CONTAINER_ID</span><br></pre></td></tr></table></figure></p><h2 id="4-终止容器"><a href="#4-终止容器" class="headerlink" title="4. 终止容器"></a>4. 终止容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop CONTAINER_ID</span><br></pre></td></tr></table></figure><p>处于终止态的容器可以通过<code>sudo docker start CONTAINER_ID</code>命令来重新启动。<br><code>sudo docker restart CONTAINER_ID</code>命令可以重启一个运行态的容器。</p><h2 id="5-进入容器"><a href="#5-进入容器" class="headerlink" title="5. 进入容器"></a>5. 进入容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker attach CONTAINER_ID</span><br></pre></td></tr></table></figure><p>用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候,所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><h2 id="6-导出容器"><a href="#6-导出容器" class="headerlink" title="6. 导出容器"></a>6. 导出容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS           PORTS             NAMES</span><br><span class="line">3060c837bd2d        ubuntu:14.04        &quot;/bin/bash&quot;              3 days ago          Up 6 hours                         nonghe</span><br><span class="line"></span><br><span class="line">sudo docker export 3060c837bd2d &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样导出容器快照到本地文件。</p><h2 id="7-导入容器快照"><a href="#7-导入容器快照" class="headerlink" title="7. 导入容器快照"></a>7. 导入容器快照</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0</span><br><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><p>通过指定URL或者某个目录来导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure></p><p>既可以使用<code>docker load</code>来导入镜像存储文件到本地镜像库，也可以使用<code>docker import</code>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保持容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2 id="8-删除容器"><a href="#8-删除容器" class="headerlink" title="8. 删除容器"></a>8. 删除容器</h2><p>处于终止状态的容器可以通过如下命令来删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm CONTAINER_ID</span><br></pre></td></tr></table></figure></p><p>如果要删除一个运行中的容器，可以添加<code>-f</code>参数。docker会发送SIGKILL信号给容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-新建并启动容器&quot;&gt;&lt;a href=&quot;#1-新建并启动容器&quot; class=&quot;headerlink&quot; title=&quot;1. 新建并启动容器&quot;&gt;&lt;/a&gt;1. 新建并启动容器&lt;/h2&gt;&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;&lt;br&gt;例：下面的命令输出一个“H
      
    
    </summary>
    
    
      <category term="docker" scheme="http://niuzhiqiang90.coding.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/27/docker%E9%95%9C%E5%83%8F/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/27/docker镜像/</id>
    <published>2017-02-27T09:15:33.000Z</published>
    <updated>2017-03-13T13:34:57.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull 镜像名</span><br></pre></td></tr></table></figure><p>例：从Docker Hub仓库下载一个Ubuntu 12.04的操作系统的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ sudo docker pull ubuntu:12.04</span><br><span class="line">12.04: Pulling from ubuntu</span><br><span class="line"></span><br><span class="line">8941035ae797: Pull complete </span><br><span class="line">191c4e1e4400: Pull complete </span><br><span class="line">fd04a9dc157f: Pull complete </span><br><span class="line">be08d59fa177: Pull complete </span><br><span class="line">ecf8c2069900: Pull complete </span><br><span class="line">8ea067ad7a27: Pull complete </span><br><span class="line">Digest: sha256:57a83f4b4f43f2d008c8ceaa9663a6f7ecd061fefa80da8f32e0f22c7b923390</span><br><span class="line">Status: Downloaded newer image for ubuntu:12.04</span><br></pre></td></tr></table></figure></p><h2 id="2-显示本地镜像"><a href="#2-显示本地镜像" class="headerlink" title="2. 显示本地镜像"></a>2. 显示本地镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu              12.04               8ea067ad7a27        4 weeks ago         103.6 MB</span><br></pre></td></tr></table></figure><h2 id="3-创建镜像"><a href="#3-创建镜像" class="headerlink" title="3. 创建镜像"></a>3. 创建镜像</h2><h3 id="3-1-修改已有的镜像"><a href="#3-1-修改已有的镜像" class="headerlink" title="3.1 修改已有的镜像"></a>3.1 修改已有的镜像</h3><ul><li>使用下载的镜像启动一个容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -t -i 镜像名 /bin/bash</span><br></pre></td></tr></table></figure></li></ul><p>例： 使用镜像ubuntu:12.04来启动一个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ sudo docker run -t -i ubuntu:12.04 /bin/bash</span><br><span class="line">root@c2b59b70c1b7:/# pwd</span><br><span class="line">/</span><br><span class="line">root@f93c7537832d:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var</span><br><span class="line">root@f93c7537832d:/# ps </span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   12 ?        00:00:00 ps</span><br></pre></td></tr></table></figure></p><ul><li><p>在容器中对安装软件<br>结束操作后，执行<code>exit</code>来退出。</p></li><li><p>提交更新后的副本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -m &quot;提交说明&quot; -a 指定更新的用户信息 用来创建镜像的容器的ID 指定目标镜像的仓库名和tag信息</span><br></pre></td></tr></table></figure></li></ul><p>创建成功后会返回这个镜像的ID信息<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -m &quot;Add node&quot; -a &quot;username&quot; aeee120a81fc testnode </span><br><span class="line"></span><br><span class="line">sudo docker images 查看新创建的镜像</span><br><span class="line">sudo docker run -t -i testnode /bin/bash  使用新创建的镜像启动容器</span><br></pre></td></tr></table></figure></p><h3 id="3-2-使用Dockerfile来创建镜像"><a href="#3-2-使用Dockerfile来创建镜像" class="headerlink" title="3.2 使用Dockerfile来创建镜像"></a>3.2 使用Dockerfile来创建镜像</h3><p>todo</p><h3 id="3-3-从本地导入"><a href="#3-3-从本地导入" class="headerlink" title="3.3 从本地导入"></a>3.3 从本地导入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cat ubuntu-14.04.tar.gz | docker import - ubuntu:14.04</span><br><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><h3 id="3-4-上传镜像"><a href="#3-4-上传镜像" class="headerlink" title="3.4 上传镜像"></a>3.4 上传镜像</h3><p>用户在Docker Hub上完成注册后，可以可以通过<code>docker push</code>命令，把自己创建的镜像上传到docker的公共仓库来共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push 镜像名</span><br></pre></td></tr></table></figure></p><h2 id="4-存出镜像"><a href="#4-存出镜像" class="headerlink" title="4. 存出镜像"></a>4. 存出镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br><span class="line">sudo docker save -o 保存文件名 镜像名</span><br></pre></td></tr></table></figure><h2 id="5-载入镜像"><a href="#5-载入镜像" class="headerlink" title="5. 载入镜像"></a>5. 载入镜像</h2><p>可以使用<code>docker load</code>从导出的本地文件中再导入到本地镜像库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker load --input ubuntu_14.04.tar</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker load &lt; ubuntu_14.04.tar</span><br></pre></td></tr></table></figure></p><p>这将导入镜像以及相关的元数据信息（包括标签等）</p><h2 id="6-删除本地镜像"><a href="#6-删除本地镜像" class="headerlink" title="6. 删除本地镜像"></a>6. 删除本地镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi IMAGE_ID</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-获取镜像&quot;&gt;&lt;a href=&quot;#1-获取镜像&quot; class=&quot;headerlink&quot; title=&quot;1. 获取镜像&quot;&gt;&lt;/a&gt;1. 获取镜像&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
      <category term="docker" scheme="http://niuzhiqiang90.coding.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker安装</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/27/docker%E5%AE%89%E8%A3%85/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/27/docker安装/</id>
    <published>2017-02-27T09:03:14.000Z</published>
    <updated>2017-06-04T13:38:04.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ubuntu通过Docker源安装最新版本"><a href="#1-ubuntu通过Docker源安装最新版本" class="headerlink" title="1. ubuntu通过Docker源安装最新版本"></a>1. ubuntu通过Docker源安装最新版本</h2><h3 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h3><p>要安装最新的Docker版本，首先需要安装apt-transport-https支持，之后通过添加源来安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure></p><h3 id="1-2-添加GPG-key"><a href="#1-2-添加GPG-key" class="headerlink" title="1.2 添加GPG key"></a>1.2 添加GPG key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv \</span><br><span class="line">               --keyserver hkp://ha.pool.sks-keyservers.net:80 \</span><br><span class="line">               --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br></pre></td></tr></table></figure><h3 id="1-3-添加对应的源"><a href="#1-3-添加对应的源" class="headerlink" title="1.3 添加对应的源"></a>1.3 添加对应的源</h3><p>源列表</p><table><thead><tr><th>Ubuntu version</th><th>Repository</th></tr></thead><tbody><tr><td>Precise 12.04 (LTS)</td><td>deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-precise main</td></tr><tr><td>Trusty 14.04 (LTS)</td><td>deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-trusty main</td></tr><tr><td>Wily 15.10</td><td>deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-wily main</td></tr><tr><td>Xenial 16.04 (LTS)</td><td>deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-xenial main</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;REPO&gt;&quot; | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure><h3 id="1-4-更新apt包的index"><a href="#1-4-更新apt包的index" class="headerlink" title="1.4 更新apt包的index"></a>1.4 更新apt包的index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="1-5-安装docker"><a href="#1-5-安装docker" class="headerlink" title="1.5  安装docker"></a>1.5  安装docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-engine</span><br><span class="line">sudo service docker start</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="2-CentOS安装"><a href="#2-CentOS安装" class="headerlink" title="2. CentOS安装"></a>2. CentOS安装</h2><h3 id="2-1-更新包"><a href="#2-1-更新包" class="headerlink" title="2.1 更新包"></a>2.1 更新包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><h3 id="2-2-添加yum源"><a href="#2-2-添加yum源" class="headerlink" title="2.2 添加yum源"></a>2.2 添加yum源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/yum.repos.d/docker.repo &lt;&lt; EOF</span><br><span class="line">[DockerRepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-3-安装docker包"><a href="#2-3-安装docker包" class="headerlink" title="2.3 安装docker包"></a>2.3 安装docker包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install docker-engine</span><br></pre></td></tr></table></figure><h3 id="2-4-开启启动"><a href="#2-4-开启启动" class="headerlink" title="2.4 开启启动"></a>2.4 开启启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker.service</span><br></pre></td></tr></table></figure><h3 id="2-5-启动服务"><a href="#2-5-启动服务" class="headerlink" title="2.5 启动服务"></a>2.5 启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="3-验证docker是否安装成功"><a href="#3-验证docker是否安装成功" class="headerlink" title="3. 验证docker是否安装成功"></a>3. 验证docker是否安装成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &apos;hello-world:latest&apos; locally</span><br><span class="line"> latest: Pulling from library/hello-world</span><br><span class="line"> c04b14da8d14: Pull complete</span><br><span class="line"> Digest: sha256:0256e8a36e2070f7bf2d0b0763dbabdd67798512411de4cdcf9431a1feb60fd9</span><br><span class="line"> Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line"> Hello from Docker!</span><br><span class="line"> This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line"> To generate this message, Docker took the following steps:</span><br><span class="line">  1. The Docker client contacted the Docker daemon.</span><br><span class="line">  2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">  3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">     executable that produces the output you are currently reading.</span><br><span class="line">  4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">     to your terminal.</span><br><span class="line"></span><br><span class="line"> To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">  $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line"> Share images, automate workflows, and more with a free Docker Hub account:</span><br><span class="line">  https://hub.docker.com</span><br><span class="line"></span><br><span class="line"> For more examples and ideas, visit:</span><br><span class="line">  https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure><p><a href="https://github.com/docker/docker" target="_blank" rel="noopener">docker on github</a><br><a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">docker install mothed</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-ubuntu通过Docker源安装最新版本&quot;&gt;&lt;a href=&quot;#1-ubuntu通过Docker源安装最新版本&quot; class=&quot;headerlink&quot; title=&quot;1. ubuntu通过Docker源安装最新版本&quot;&gt;&lt;/a&gt;1. ubuntu通过Docke
      
    
    </summary>
    
    
      <category term="docker" scheme="http://niuzhiqiang90.coding.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>linux添加swap</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/14/linux%E6%B7%BB%E5%8A%A0swap/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/14/linux添加swap/</id>
    <published>2017-02-14T06:39:33.000Z</published>
    <updated>2017-02-15T05:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-swap说明"><a href="#1-swap说明" class="headerlink" title="1. swap说明"></a>1. swap说明</h2><p>物理内存就是计算机的实际内存大小，由RAM芯片组成的。<br>虚拟内存则是虚拟出来的，使用磁盘代替内存。<br>虚拟内存的出现，让机器内存不够的情况得到部分解决。当程序运行起来由操作系统做具体虚拟内存到物理内存的替换和载。这里的虚拟内存就是swap</p><p>当物理内存使用完或者达到一定比例之后，我们可以使用swap做临时的内存使用。当物理内存和swap都被使用完那么就会出错，out of memory。</p><h2 id="2-使用dd创建swap"><a href="#2-使用dd创建swap" class="headerlink" title="2. 使用dd创建swap"></a>2. 使用dd创建swap</h2><h3 id="2-1-查看当前内存"><a href="#2-1-查看当前内存" class="headerlink" title="2.1 查看当前内存"></a>2.1 查看当前内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ free -h</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          7.7G       6.0G       1.6G       875M       476M       3.2G</span><br><span class="line">-/+ buffers/cache:       2.4G       5.3G</span><br><span class="line">Swap:         0B         0B       0B</span><br></pre></td></tr></table></figure><h3 id="2-2-创建swap文件"><a href="#2-2-创建swap文件" class="headerlink" title="2.2 创建swap文件"></a>2.2 创建swap文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ sudo -s</span><br><span class="line">root@localhost:~# dd if=/dev/zero of=/mnt/swap_mount_point bs=1M count=2048</span><br><span class="line">2048+0 records in</span><br><span class="line">2048+0 records out</span><br><span class="line">2147483648 bytes (2.1 GB) copied, 16.7229 s, 128 MB/s</span><br><span class="line"></span><br><span class="line">root@localhost:~# ls -lh /mnt/swap_mount_point </span><br><span class="line">-rw-r--r-- 1 root root 2.0G Feb 14 18:08 /mnt/swap_mount_point</span><br><span class="line"></span><br><span class="line">root@localhost:~# file /mnt/swap_mount_point </span><br><span class="line">/mnt/swap_mount_point: data</span><br></pre></td></tr></table></figure><h3 id="2-3-格式化swap文件"><a href="#2-3-格式化swap文件" class="headerlink" title="2.3 格式化swap文件"></a>2.3 格式化swap文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# mkswap /mnt/swap_mount_point </span><br><span class="line">Setting up swapspace version 1, size = 2097148 KiB</span><br><span class="line">no label, UUID=2ed6629c-4b31-499b-b21d-2235971f8678</span><br><span class="line">root@localhost:~# file /mnt/swap_mount_point </span><br><span class="line">/mnt/swap_mount_point: Linux/i386 swap file (new style), version 1 (4K pages), size 524287 pages, no label, UUID=2ed6629c-4b31-499b-b21d-2235971f8678</span><br></pre></td></tr></table></figure><h3 id="2-4-挂载"><a href="#2-4-挂载" class="headerlink" title="2.4 挂载"></a>2.4 挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# swapon /mnt/swap_mount_point </span><br><span class="line">root@localhost:~# free -h</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          7.7G       7.5G       197M       878M       476M       4.7G</span><br><span class="line">-/+ buffers/cache:       2.3G       5.3G</span><br><span class="line">Swap:         2G       264K       2G</span><br></pre></td></tr></table></figure><h3 id="2-5-添加开机启动"><a href="#2-5-添加开机启动" class="headerlink" title="2.5 添加开机启动"></a>2.5 添加开机启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# echo &quot;/mnt/swap_mount_point swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure><h2 id="3-相关命令"><a href="#3-相关命令" class="headerlink" title="3. 相关命令"></a>3. 相关命令</h2><ul><li><p>挂载swap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ swapon /mnt/swap_mount_ponit</span><br></pre></td></tr></table></figure></li><li><p>卸载swap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ swapoff /mnt/swap_mount_point</span><br></pre></td></tr></table></figure></li><li><p>查看swap使用情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ swapon -s </span><br><span class="line">或</span><br><span class="line">×××@localhost: ~$ cat /proc/swaps</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-swap的优化"><a href="#4-swap的优化" class="headerlink" title="4. swap的优化"></a>4. swap的优化</h2><p>在ubuntu中swappiness参数值的大小对如何使用swap分区有很大的关系。<br>swappiness=0 表示最大限度使用物理内存。然后才是swap分区<br>swappiness=100 表示积极地使用swap分区，并把内存上的数据及时地搬运到swap空间上。</p><p><strong>swappiness值的修改方法</strong></p><ul><li><p>方法1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ sudo sysctl vm.swappiness=60</span><br></pre></td></tr></table></figure></li><li><p>方法2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">×××@localhost: ~$ sudo vi /etc/sysctl.conf</span><br><span class="line">在文件尾添加`vm.swappiness=60`，然后刷新内核参数</span><br><span class="line">×××@localhost: ~$ sudo sysctl -p</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-swap说明&quot;&gt;&lt;a href=&quot;#1-swap说明&quot; class=&quot;headerlink&quot; title=&quot;1. swap说明&quot;&gt;&lt;/a&gt;1. swap说明&lt;/h2&gt;&lt;p&gt;物理内存就是计算机的实际内存大小，由RAM芯片组成的。&lt;br&gt;虚拟内存则是虚拟出来的，使
      
    
    </summary>
    
    
      <category term="linux" scheme="http://niuzhiqiang90.coding.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu指定默认编辑器</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/07/ubuntu%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/07/ubuntu指定默认编辑器/</id>
    <published>2017-02-07T05:28:17.000Z</published>
    <updated>2017-02-07T05:37:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu默认的编辑器为nano，例如执行如下命令时就会使用nano来打开<br><code>sudo visudo</code>或者<code>git commit --amend</code></p><p>如果想要设置成默认使用自己习惯的vi，可以执行如下命令进行选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-alternatives --config editor </span><br><span class="line">There are 4 choices for the alternative editor (providing /usr/bin/editor).</span><br><span class="line">  Selection    Path                Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /bin/nano            40        auto mode</span><br><span class="line">  1            /bin/ed             -100       manual mode</span><br><span class="line">  2            /bin/nano            40        manual mode</span><br><span class="line">  3            /usr/bin/vim.basic   30        manual mode</span><br><span class="line">  4            /usr/bin/vim.tiny    10        manual mode</span><br><span class="line">Press enter to keep the current choice[*], or type selection number:</span><br></pre></td></tr></table></figure><p>输入<code>3</code>就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ubuntu默认的编辑器为nano，例如执行如下命令时就会使用nano来打开&lt;br&gt;&lt;code&gt;sudo visudo&lt;/code&gt;或者&lt;code&gt;git commit --amend&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想要设置成默认使用自己习惯的vi，可以执行如下命令进行选
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://niuzhiqiang90.coding.me/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu修改网卡名称</title>
    <link href="http://niuzhiqiang90.coding.me/2017/02/07/ubuntu%E4%BF%AE%E6%94%B9%E7%BD%91%E5%8D%A1%E5%90%8D%E7%A7%B0/"/>
    <id>http://niuzhiqiang90.coding.me/2017/02/07/ubuntu修改网卡名称/</id>
    <published>2017-02-07T03:21:00.000Z</published>
    <updated>2017-02-07T05:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天强迫症又犯了，想要把网卡的名称改为eth0和wlan0<br>按照网上的方法试了几种，都没有成功，下面记录下我修改成功的方法。</p><h2 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h2><p>Open the file /etc/udev/rules.d/70-persistent-net.rules with your favorite editor.<br>Find the rule matching your MAC address.<br>Change the NAME value from eth1 to eth0 i.e. NAME=”eth0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/udev/rules.d/70-persistent-net.rules</span><br></pre></td></tr></table></figure><p>找到你要修改的网卡的MAC，修改对应的<code>NAME</code>值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># PCI device 0x10ec:0x8168 (r8169)</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;50:7b:9d:55:47:2e&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;</span><br><span class="line"> </span><br><span class="line"># PCI device 0x168c:0x0042 (ath10k_pci)</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;30:52:cb:68:81:17&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;wlan*&quot;, NAME=&quot;wlan0&quot;</span><br></pre></td></tr></table></figure></p><h2 id="2-使修改生效"><a href="#2-使修改生效" class="headerlink" title="2. 使修改生效"></a>2. 使修改生效</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo udevadm trigger</span><br></pre></td></tr></table></figure><p>运行<code>ifconfig</code>查看网卡名称是否已经修改过来，如果没成功，就重启一下吧。</p><p><a href="http://askubuntu.com/questions/637591/my-ethernet-interface-name-has-changed-from-eth0-to-eth1" target="_blank" rel="noopener">From askubuntu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天强迫症又犯了，想要把网卡的名称改为eth0和wlan0&lt;br&gt;按照网上的方法试了几种，都没有成功，下面记录下我修改成功的方法。&lt;/p&gt;
&lt;h2 id=&quot;1-修改配置文件&quot;&gt;&lt;a href=&quot;#1-修改配置文件&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://niuzhiqiang90.coding.me/tags/ubuntu/"/>
    
  </entry>
  
</feed>
