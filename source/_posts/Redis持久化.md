---
title: Redis持久化
date: 2018-10-16 20:46:09
tags:
---


## 1. Redis持久化 

Redis提供了多种不同级别的持久化方式：
- RDB持久化可以在指定的时间间隔内生成数据集的时间点快照。
- AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。  
  AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件的末尾。   
  **Redis还可以在后台对AOF文件进行重写，使得AOF文件的体积不会超出保存数据集状态所需的实际大小。**
- Redis还可以同时使用AOF持久化和RDB持久化。在这种情况下，当Redis重启时，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比 RDB 文件所保存的数据集更完整。
- 你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

## 2. RDB的优点

- RDB是一个非常紧凑的文件，它保存了Redis在某个时间点上的数据集。这种文件非常适合用于进行备份:比如说，你可以每小时备份一次RDB文件，这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。
- RDB非常适用于灾难恢复：它只有一个文件，并且内容都非常紧凑。
- RDB最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是`fork`出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O操作。
- RDB在恢复大数据集时的速度比AOF的恢复速度快。

## 3. RDB的缺点
- RDB不适用于尽量避免在服务器故障时丢失数据。虽然Redis允许你设置不同的保存点来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少5分钟才保存一次RDB文件。在这种情况下，一旦发生故障停机，你就可能丢失好几分钟的数据。
- 每次保存RDB文件的时候，Redis都要`fork()`出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时，`fork()`可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。虽然AOF重写也需要进行`fork()`,但无论AOF重写的执行间隔有多长，数据的耐久性都不会又任何损失。

## 4. AOF的优点

- 使用AOF持久化会让Redis变得非常耐久  
你可以设置不同的`fsync`策略，比如：无`fsync`、每秒一次`fsync`或者每次执行写入命令时`fsync`
**AOF默认策略为每秒钟`fsync`一次**，在这种配置下，Redis仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据。（`fsync`会在后台线程执行，所以主线程可以继续努力地处理命令请求）
- AOF文件是一个只进行追加操作的日志文件，因此对AOF文件的写入不需要进行`seek`，即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机等），`redis-check-aof`工具也可以轻易的修复这种问题。
- Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写。重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新AOF文件的过程中，会继续将命令追加到现有AOF文件里面，即使重写过程中发生停机，现有的AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。
- AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此，AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松。导出AOF文件也非常简单：举个例子，如果你不小心执行了`FLUSHALL`命令，只要AOF文件没有被重写，那么只要停止服务器，移除AOF文件末尾的`FLUSHALL`命令，并重启Redis，就可以将数据集恢复到`FLUSHALL`执行之前的状态。

## 5. AOF的缺点
- 对于相同的数据集来说，AOF文件的要大于RDB文件。
- 根据所使用的`fsync`策略，AOF的速度可能会慢于RDB。在一般情况下，每秒`fsync`的性能依然非常高，而关闭`fsync`可以让AOF的速度和RDB一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间。
- AOF在过去曾经发生过**因为个别命令的原因，导致AOF文件在重新载入时，无法将数据集恢复成保存时的原样**的bug.(例如：阻塞命令`BRPOPLPUSH`就曾经引起过这样的bug)测试套件里为这种情况添加了测试：它们会自动生成随机的、复杂的数据集，并通过重新载入这些数据来确保一切正常。虽然这种bug在AOF文件中并不常见，单对比来说，RDB几乎是不可能出现这种bug的。

## 6. RDB和AOF的选择

- 一般来说。如果想要达到足以媲美PostgreSQL的数据安全性，应该同时使用这两种持久化功能。
- 如果非常关心数据，但是仍然可以承受数分钟以内的数据丢失，那么可以只使用RDB持久化。
- 不推荐只使用AOF持久化，因为定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免之前提到的AOF相关的bug。
将来可能将AOF和RDB整合成单个持久化模型。

## 7. RDB快照
默认情况下，Redis将数据库快照保存在名字为`dump.rdb`的二进制文件中。  
可以对Redis进行设置，让它满足在**N 秒内数据集至少有M个改动**时自动保存一次数据集。  
也可以通过调用`SAVE`或`BGSAVE`手动让Redis进行数据集保存操作。  
比如，以下设置会让Redis在满足60秒内有至少1000个键被改动时自动保存一次数据集  
`save 60 1000`  
这种持久化方式被称为快照。

## 8. 快照的运作方式
当Redis需要保存`dump.rdb`文件时，服务器执行以下操作
1. Redis调用`fork()`,同时拥有父进程和子进程。
1. 子进程将数据集写入到一个临时RDB文件中。
3. 当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。  
这种工作方式使得Redis可以从写时复制机制中获益。


## 9. 只进行追加操作的文件aof
快照功能并不是非常耐久：如果Redis因为某些原因而造成故障停机，那么服务器将丢失最近写入且仍未保存到快照中的哪些数据。
尽管对于某些程序来说，数据耐久性并不是最重要的考虑因素，但是对于那些追求完全耐久能力的程序来说，快照功能就不太适用了。  
打开AOF功能
```
appendonly yes
```
从现在开始，每当Redis执行一个改变数据集的命令时，这个命令就会被追加到AOF文件的末尾。  
这样的话，当Redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。 


## 10. AOF重写
因为AOF的运作方式是不断地将命令追加到文件的末尾，所以随着写入命令的不断增加，AOF文件的体积也会变得越来越大。
例如：如果你对一个计数器调用了100次`INCR`，那么仅仅是为了保存这个计数器的当前值，AOF文件就需要使用100条记录。
然而实际上，只需要一条`SET`命令已经足以保存计数器的当前值了，其余99条记录实际上都是多余的。
为了处理这种情况，Redis支持一种有趣的特性：可以在不打断服务客户端的情况下，对AOF文件进行重建。
执行`BGREWRITEAOF`命令，Redis将生成一个新的AOF文件，这个文件包含重建当前数据集所需的最少命令。

## 11. AOF有多耐久
可以配置Redis多久才将数据`fsync`磁盘一次。  
有三个选项：
- 每次有新命令追加到AOF文件时就执行一次`fsync`:非常慢，也非常安全。
- 每秒`fsync`一次：足够快（和使用RDB持久化差不多），并且在故障时只会丢失1秒的数据。
- 从不`fsync`:将数据交给操作系统来处理。更快，也更不安全的选择。
推荐并且默认的措施是每秒`fsync`一次，这种`fsync`策略可以兼顾速度和安全性。

## 12. 如果AOF文件出错了，怎么办？
服务器可能在程序正在对AOF文件进行写入是停机，如果停机造成了AOF文件出错，那么Redis在重启时会拒绝载入这个AOF文件，从而确保数据的一致性不会被破坏。  
当发生这种情况时，可以使用以下方法来修复出错的AOF文件：
1. 为现有的AOF文件创建一个备份
2. 使用Redis附带的`Redis-check-aof`程序对原来的AOF文件进行修复。
```
$ redis-check-aof --fix
```
3. [可选] 使用`diff -u`对比修复后的AOF文件和原始AOF文件的备份。查看两个文件之间的不同之处。
4. 重启Redis服务器，等待服务器载入修复后的AOF文件，并进行数据恢复。


## 13. AOF的运作方式
AOF重写和RDB创建快照一样，都巧妙地利用了写时复制。  
以下是AOF重写的执行步骤：
1. Redis执行`fork()`，现在同时拥有父进程和子进程。
2. 子进程开始将新AOF文件的内容写入到临时文件。
3. 对于所有新执行的写入命令，父进程一边将它们积累到一个内存缓存中，一边将这些改动追加到现有AOF文件的末尾：这样即使在重写的中途发生停机，现有的AOF文件也还是安全的。
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号后，将内存缓存中的所有数据追加到新AOF文件的末尾。
5. 现在Redis原子地用新文件替换旧文件，之后所有命令都会直接追加到新AOF文件的末尾。


## 14. 怎么从RDB持久化切换到AOF持久化
在Redis2.2或以上版本，可以在不重启的情况下，从RDB切换到AOF：  
1. 为最新的`dump.rdb`文件创建一个备份。
2. 将备份放到一个安全的地方。
3. 执行以下两条命令：
```
开启AOF功能：Redis会阻塞直到初始AOF文件创建完成为止，之后Redis会继续处理命令请求，并开始将写入命令追加到AOF文件末尾  
redis-cli> CONFIG SET appendonly yes  
关闭RDB功能 这一步是可选的，如果愿意的话也可以同时使用RDB和AOF这两种持久化功能
redis-cli> CONFIG SET save " "
```
4. 确保命令执行之后，数据库的键的数量没有改变。  
5. 确保写命令会被正确地追加到AOF文件的末尾。  
**别忘了在配置文件中打开AOF功能！否则，服务器重启之后，之前通过`CONFIG SET`设置的配置就会被遗忘，程序会按原来的配置启动服务器**
**<font color=red>不可以直接修改配置文件重启服务，这样会从空的aof文件里读取，导致数据集被清空</font>**

## 15. RDB和AOF之间的相互作用
在版本号大于等于2.4的Redis中，`BGSAVE`执行的过程中，不可以执行`BGREWRITEAOF`  
反过来，在`BGREWRITEAOF`执行的过程中，也不可以执行`BGSAVE`  
这可以防止两个Redis后台进程同时对磁盘进行大量的I/O操作。
如果`BGSAVE`正在执行，并且用户显式地调用`BGREWRITEAOF`命令，那么服务器将向用户回复一个OK状态，并告知用户。
`BGREWRITEAOF`已经被预订执行：一旦`BGSAVE`执行完毕，`BGREWRITEAOF`就会正式开始。  
当Redis启动时，如果RDB持久化和AOF持久化都被打开了，那么程序会优先使用AOF文件来恢复数据集，因为AOF文件所保存的数据通常是最完整的。

## 16. 备份Redis数据
一定要备份你的数据库！
磁盘故障，节点失效，诸如此类的问题都可能让你的数据消失不见，不进行备份是非常危险的
Redis对于数据备份是非常友好的，因为你可以在服务器运行时对RDB文件进行复制：RDB文件一旦被创建，就不会进行任何修改。当服务器要创建一个新的RDB文件时，它先将文件的内容保存在一个临时文件里面，当临时文件写入完毕时，程序才使用rename原子地用临时文件替换原来的RDB文件。  
也就是说，无论何时，复制RDB文件都是绝对安全的。


